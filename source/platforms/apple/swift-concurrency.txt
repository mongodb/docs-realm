.. _swift-concurrency:

=============================
Swift Concurrency - Swift SDK
=============================

.. meta::
   :description: Learn how to use Atlas Device SDK with Swift language concurrency features, including which APIs support async/await syntax.
   :keywords: Realm, Swift SDK

.. facet::
  :name: genre
  :values: reference

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Swift's concurrency system provides built-in support for writing asynchronous 
and parallel code in a structured way. For a detailed overview of the 
Swift concurrency system, refer to the `Swift Programming Language Concurrency
topic <https://docs.swift.org/swift-book/documentation/the-swift-programming-language/concurrency/>`__.

While the considerations on this page broadly apply to using the Swift SDK with 
Swift concurrency features, Swift SDK version 10.39.0 adds support
for using the SDK with Swift Actors. You can use the SDK isolated to a single
actor or use the SDK across actors.

The SDK's actor support simplifies using the SDK in a MainActor and background
actor context, and supersedes much of the advice on this page regarding
concurrency considerations. For more information, refer to 
:ref:`swift-use-sdk-with-actors`.

SDK Concurrency Caveats
-----------------------

As you implement concurrency features in your app, consider this caveat 
about the SDK's threading model and Swift concurrency threading behaviors.

.. _swift-suspend-execution-with-await:

Suspending Execution with Await
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Anywhere you use the Swift keyword ``await`` marks a possible suspension 
point in the execution of your code. With Swift 5.7, once your code suspends, 
subsequent code might not execute on the same thread. This means that 
anywhere you use ``await`` in your code, the subsequent code could be 
executed on a different thread than the code that precedes or follows it. 

This is inherently incompatible with the SDK's :ref:`live object paradigm 
<sdks-live-and-frozen-objects>`. Live objects, collections, and database
instances are **thread-confined**: that is, they are only valid on the thread
on which they were created. Practically speaking, this means you cannot pass
live instances to other threads. However, the SDK offers several 
mechanisms for :ref:`sharing objects across threads 
<sdks-communication-across-threads>`. These mechanisms typically require 
your code to do some explicit handling to safely pass data across threads.

You can use some of these mechanisms, such as :ref:`frozen objects 
<sdks-frozen-objects>` or the :ref:`ThreadSafeReference 
<sdks-thread-safe-reference>`, to safely use SDK objects and instances 
across threads with the ``await`` keyword. You can also avoid 
threading-related issues by marking any asynchronous SDK code with 
``@MainActor`` to ensure your apps always execute this code on the main 
thread.

As a general rule, keep in mind that using the SDK in an ``await`` context 
*without* incorporating threading protection may yield inconsistent behavior. 
Sometimes, the code may succeed. In other cases, it may throw an error 
related to writing on an incorrect thread.

.. _swift-async-await-apis:

Async/Await APIs
----------------

Many Swift SDK APIs that involve working with :ref:`an Atlas App 
Services app <sdks-connect-to-atlas>` or a :ref:`synchronized database 
<sdks-configure-and-open-synced-database>` are compatible with Swift's
async/await syntax. For examples, check out:

- :ref:`Authenticate Users <sdks-authenticate-users>`
- :ref:`Manage Email/Password Users <sdks-manage-email-password-users>`
- :ref:`Link User Identities <sdks-link-user-identities>`
- :ref:`Open a Synced Database <sdks-configure-and-open-synced-database>` or a 
  :ref:`non-synced database <sdks-open-database-asynchronously>`
- :ref:`Await notifications from another actor <swift-observe-notifications-on-another-actor>`
- :ref:`Manage Sync Subscriptions <sdks-manage-sync-subscriptions>`
- :ref:`Async/Await Call a Serverless Function <sdks-call-function>`
- :ref:`Async/Await Query MongoDB <sdks-access-mongodb>`
- :ref:`Async/Await CRUD operations <swift-perform-background-writes>`

If you have specific feature requests related to Swift async/await APIs,
check out the `MongoDB Feedback Engine for Realm 
<https://feedback.mongodb.com/forums/923521-realm>`_. The Swift SDK
team plans to continue to develop concurrency-related features based on 
community feedback and Swift concurrency evolution.

.. _swift-perform-background-writes:

Perform Background Writes
~~~~~~~~~~~~~~~~~~~~~~~~~

A commonly-requested use case for asynchronous code is to perform write 
operations in the background without blocking the main thread. 

The SDK has two APIs that allow for performing asynchronous writes:

- The :swift-sdk:`writeAsync() <Structs/Realm.html#/s:10RealmSwift0A0V10writeAsync_10onCompletes6UInt32Vyyc_ys5Error_pSgcSgtF>` 
  API allows for performing async writes using Swift completion handlers.
- The :swift-sdk:`asyncWrite() <Structs/Realm.html#/s:10RealmSwift0A0V10asyncWriteyxxyKXEYaKlF>`
  API allows for performing async writes using Swift async/await syntax.

Both of these APIs allow you to add, update, or delete objects in the 
background without using frozen objects or passing a thread-safe reference. 

With the ``writeAsync()`` API, waiting to obtain the write lock and 
committing a transaction occur in the background. The write block itself 
runs on the calling thread. This provides thread-safety without requiring 
you to manually handle frozen objects or passing references across threads. 

However, while the write block itself is executed, this does block new 
transactions on the calling thread. This means that a large write using
the ``writeAsync()`` API could block small, quick writes while it executes.

The ``asyncWrite()`` API suspends the calling task while waiting for its 
turn to write rather than blocking the thread. In addition, the actual 
I/O to write data to disk is done by a background worker thread. For small 
writes, using this function on the main thread may block the main thread 
for less time than manually dispatching the write to a background thread.

For more information, including code examples, refer to :ref:`sdks-create-objects-in-background`.

Tasks and TaskGroups
--------------------

Swift concurrency provides APIs to manage :apple:`Tasks <documentation/swift/task>` 
and :apple:`TaskGroups <documentation/swift/taskgroup>`. The `Swift concurrency
documentation <https://docs.swift.org/the-swift-programming-language/concurrency/>`__ 
defines a task as a unit of work that can be run asynchronously as part of 
your program. Task allows you to specifically define a unit of asynchronous 
work. TaskGroup lets you define a collection of Tasks to execute as a unit 
under the parent TaskGroup. 

Tasks and TaskGroups provide the ability to yield the thread to other 
important work or to cancel a long-running task that could be blocking 
other operations. To get these benefits, you might be tempted to use Tasks
and TaskGroups to manage database writes in the background.

However, the thread-confined constraints described in :ref:`Suspending 
Execution with Await <swift-suspend-execution-with-await>` above apply in
the Task context. If your Task contains ``await`` points, subsequent code 
might run or resume on a different thread and violate the SDK's thread
confinement.

You must annotate functions that you run in a Task context with ``@MainActor`` 
to ensure code that accesses the database only runs on the main thread. This
negates some of the benefits of using Tasks, and may mean this is not a good
design choice for apps that use the SDK unless you are using Tasks solely for 
networking activities like managing users.

Actor Isolation
---------------

.. seealso:: Use the Swift SDK with Swift Actors

   The information in this section is applicable to Swift SDK versions earlier
   than 10.39.0. Starting in Swift SDK version 10.39.0 and newer, 
   the SDK supports using Swift Actors and related async functionality.

   For more information, refer to :ref:`swift-actor-isolated-realm`. 

Actor isolation provides the perception of confining database access to a 
dedicated actor, and therefore seems like a safe way to manage database 
access in an asynchronous context.

However, using the database in a non-``@MainActor`` async function is currently 
not supported. 

In Swift 5.6, this would often work by coincidence. Execution after an 
``await`` would continue on whatever thread the awaited thing ran on. 
Using ``await Realm()`` in an async function would result in the code 
following that running on the main thread until your next call to an 
actor-isolated function. 

Swift 5.7 instead hops threads whenever changing actor isolation contexts. 
An unisolated async function always runs on a background thread instead.

If you have code which uses ``await Realm()`` and works in 5.6, marking 
the function as ``@MainActor`` will make it work with Swift 5.7. It will 
function how it did - unintentionally - in 5.6.

Errors Related to Concurrency Code
----------------------------------

Most often, the error you see related to accessing the database through
concurrency code is ``Realm accessed from incorrect thread.`` This is due to
the thread-isolation issues described on this page.

To avoid threading-related issues in code that uses Swift concurrency features:

- Upgrade to a version of the Swift SDK that supports actor-isolated databases,
  and use this as an alternative to manually managing threading. For more 
  information, refer to :ref:`swift-actor-isolated-realm`.
- Do not change execution contexts when accessing a database. If you open a
  database on the main thread to provide data for your UI, annotate subsequent
  functions where you access the database asynchronously with ``@MainActor`` to
  ensure it always runs on the main thread. Remember that ``await`` marks a
  suspension point that could change to a different thread.
- Apps that do not use actor-isolated databases can use the ``writeAsync``
  API to :ref:`perform a background write <sdks-create-objects-in-background>`.
  This manages database access in a thread-safe way without requiring you to
  write specialized code to do it yourself. This is a special API that
  outsources aspects of the write process - where it is safe to do so - to run
  in an async context. Unless you are writing to an actor-isolated database,
  you do not use this method with Swift's ``async/await`` syntax. Use this
  method synchronously in your code. Alternately, you can use the
  ``asyncWrite`` API with Swift's ``async/await`` syntax when awaiting writes
  to asynchronous databases.
- If you want to explicitly write concurrency code that is not actor-isolated 
  where accessing a database is done in a thread-safe way, you can explicitly 
  :ref:`pass instances across threads <sdks-communication-across-threads>` where 
  applicable to avoid threading-related crashes. This does require a good 
  understanding of the SDK's threading model, as well as being mindful of 
  Swift concurrency threading behaviors.

.. _concurrency-page-sendable-thread-confined-reference:

Sendable, Non-Sendable, and Thread-Confined Types
------------------------------------------------

.. include:: /includes/swift-api-sendable-thread-confined-reference.rst
