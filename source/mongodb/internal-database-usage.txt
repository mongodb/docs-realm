.. _internal-db-usage:

=======================
Internal Database Usage
=======================

{+service+} uses your linked MongoDB Atlas cluster to manage some
internal operations. In general, you do not need to know about these
operations to use {+service-short+}.

System-Generated Cluster Users
------------------------------

{+service+} automatically creates a :manual:`MongoDB user
</core/security-users>` for each app linked to a cluster. These users
are for internal use only and cannot be edited or manually deleted. If
you delete a {+app+}, the associated user will also be deleted.

Users generated by {+service+} have names of the form:
``mongodb-realm-<your app id>``

.. _transactional-locks:

Transactional Locks
-------------------

{+service+} connects to standard MongoDB Atlas clusters, which
means that you can connect directly to a :term:`linked cluster`
using another tool such as the :binary:`~bin.mongo` shell or
{+compass+}. There are no special considerations when reading
data from a linked cluster with another tool.

While running update operations, {+backend+} temporarily adds a
reserved field, ``_id__baas_transaction``, to documents.
Once a document is successfully updated, {+backend+} removes this
field. If you want to use another tool to modify data in a
collection, ensure that you :manual:`$unset
</reference/operator/update/unset>` this field prior to
making changes.

For example, if you are using the :mdb-shell:`mongosh </>` shell to
update documents in the products collection, your command
might resemble the following code:

.. code-block:: sh
   :emphasize-lines: 3

   db.products.update(
      { sku: "unknown" },
      { $unset: { _id__baas_transaction: "" } }
   )

.. _unsynced-documents:

Unsynced Documents
------------------

If the collection in which you create and modify objects is also
accessed by :ref:`{+sync+} clients <sync>`, you must ensure that the
data conforms to the {+service-short+} :ref:`object schema
<object-schema>` defined on the collection. Consider the following
scenario:

- You have a collection of objects that is used by {+sync+} clients. The 
  **object schema** for the collection looks like this:

  .. code-block:: js
     :copyable: false

     type Person = {
       _id: BSON.ObjectId;
       name: string;
       address: string;
       age: number;
     };
  
- Using a {+service-short+} client (say, {+compass+}), you create and
  insert a document into the collection. The ``age`` property of this
  document has a value of "forty two". 
  
- Because of MongoDB's flexible schema, there is no error when inserting
  the document. However, because the the Sync object schema defines the
  ``age`` property as type ``number``, the object fails schema
  validation and is not pushed to Sync.

- The collection is now divergent: Sync clients do not see the new
  document, but {+service+} clients do. 

The same scenario holds true if a valid document is modified outside of
{+sync+} such that one or more properties no longer conform to the Sync
schema. 

Any document that fails the object schema validation is added to the
``__realm_sync.unsynced_documents`` collection (along with the reason
for the failure) and will also be logged in the Realm UI ``Logs``
console. If there are 100,000 or more documents that can't be synced,
the Realm app is paused.

**Summary**
  If your data is used by Sync clients but can also be created or
  modified outside of Realm Sync, you must ensure those creations and
  modifications match the defined object schema on the collection. For
  documents that have failed, you can replace, update, or delete &
  re-add each document.

.. important::

   You can read from the ``__realm_sync.unsynced_documents`` collection,
   but you should not modify it in any way.
