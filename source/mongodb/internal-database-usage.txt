.. _internal-db-usage:

=======================
Internal Database Usage
=======================

{+service+} uses your linked MongoDB Atlas cluster to manage some
internal operations. In general, you do not need to know about these
operations to use {+service-short+}.

System-Generated Cluster Users
------------------------------

{+service+} automatically creates a :manual:`MongoDB user
</core/security-users>` for each app linked to a cluster. These users
are for internal use only and cannot be edited or manually deleted. If
you delete a {+app+}, the associated user will also be deleted.

Users generated by {+service+} have names of the form:
``mongodb-realm-<your app id>``

.. _transactional-locks:

Transactional Locks
-------------------

{+service+} connects to standard MongoDB Atlas clusters, which
means that you can connect directly to a :term:`linked cluster`
using another tool such as the :binary:`~bin.mongo` shell or
{+compass+}. There are no special considerations when reading
data from a linked cluster with another tool.

While running update operations, {+backend+} temporarily adds a
reserved field, ``_id__baas_transaction``, to documents.
Once a document is successfully updated, {+backend+} removes this
field. If you want to use another tool to modify data in a
collection, ensure that you :manual:`$unset
</reference/operator/update/unset>` this field prior to
making changes.

For example, if you are using the :mdb-shell:`mongosh </>` shell to
update documents in the products collection, your command
might resemble the following code:

.. code-block:: sh
   :emphasize-lines: 3

   db.products.update(
      { sku: "unknown" },
      { $unset: { _id__baas_transaction: "" } }
   )

.. _unsynced-documents:

Unsynced Documents
------------------

If a document in a :ref:`synced <sync>` collection does not conform to
the collection's schema, it cannot be synced to client apps. If there
are 100,000 or more unsyncable documents, {+service-short+} pauses sync
for the app.

{+service-short+} stores a information about unsyncable documents in the
``__realm_sync.unsynced_documents`` collection.

.. important::

   You can read from the ``__realm_sync.unsynced_documents`` collection,
   but you should not modify it in any way.

A common cause for unsyncable documents is data added or modified
outside of the context of your app.

Consider the following scenario:

1. An app has a ``pets`` collection with the following schema:

   .. code-block:: json
 
      {
        "title": "Pet",
        "required": ["_id", "type", "name", "age"],
        "properties": {
          "_id": { "bsonType: "objectId" },
          "type": { "bsonType: "string" },
          "name": { "bsonType: "string" },
          "age": { "bsonType: "int" }
        }
      };

#. Someone adds a document directly to the ``pets`` collection using a
   MongoDB driver, MongoDB compass, or a {+service-short+} system
   function. The document's ``age`` field contains a string, not a
   number, which does not match your app's schema. MongoDB does not
   natively enforce your app's schema, so it allows the insert without a
   warning or error.

   .. code-block:: json
      :emphasize-lines: 5
      
      {
        "_id": "5ae782e48f25b9dc5c51c4a5",
        "type": "dog",
        "name": "Fido",
        "age": "7"
      }
  
#. Once inserted, the document fails schema validation in your app and
   cannot be synced. The app stores the failure in the
   ``unsynced_documents`` collection:

   .. code-block:: json
      
      {
        "_id": "6183021879247167daacd8dc",
        "appId": "6183021373247568dcdcd3ed",
        "documentId": "5ae782e48f25b9dc5c51c4a5",
        "ns": {
          "db": "myDatabase",
          "coll": "pets"
        },
        "reason": "invalid schema"
      }

**Summary**
  If your data is used by Sync clients but can also be created or
  modified outside of Realm Sync, you must ensure those creations and
  modifications match the defined object schema on the collection. For
  documents that have failed, you can replace, update, or delete &
  re-add each document.
