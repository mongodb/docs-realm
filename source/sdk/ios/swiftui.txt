.. _ios-swiftui-combine-quick-start:

===========================================
Use Realm Database with SwiftUI and Combine
===========================================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------

This page contains instructions to quickly get {+client-database+} integrated
into your SwiftUI and Combine app. 

Prerequisites
-------------

Before you begin, ensure you have:

- :ref:`Installed the iOS SDK <ios-install>` with a minimum iOS target of 14.0.
- Xcode 12.2 or later (minimum Swift version 5.3.1).

This quick start guide includes optional support for :ref:`{+sync+} <sync>`. If
you wish to integrate the quick start with {+sync+}, ensure you have:

- :ref:`Created a {+app+} <create-a-realm-app>`.
- :ref:`Enabled anonymous authentication <anonymous-authentication-configuration>`.
- :ref:`Enabled {+sync+} <enable-sync>`.

.. note::

   The code example presented below requires a minimum iOS target of 14.0, which
   requires Xcode 12.2 or later. You might be able to use iOS 13.x by adapting the
   code to remove iOS 14.0 features such as the ``SwiftUI.App`` class, but that
   is out of scope of this guide.

The Code
--------

Paste the following into your main file, such as ``QuickStart.swift``. Delete
any other ``@main`` ``App`` classes that Xcode generated for your project (for
example, in MyProjectApp.swift). 

If you are using {+sync+}, find the ``USE_REALM_SYNC`` flag at the top of the
file and set it to ``true``. Update ``YOUR_REALM_APP_ID_HERE`` to your
:ref:`{+app+} ID <find-your-app-id>`. Run the app.

.. literalinclude:: /examples/generated/code/start/QuickStart.codeblock.complete-swiftui-combine-quick-start.swift
   :language: swift

The Explanation
---------------

App Overview
~~~~~~~~~~~~

If you opted in to using :ref:`{+sync+} <enable-sync>`, the first screen is the
**LoginView**. Otherwise, you start at the **ItemsView**.

When you press the :guilabel:`Log in` button, the app navigates to the
ItemsView, where you see a list of **items** in a single **group**.

On the ItemsView, you can log out (if using {+sync+}), edit the list, and add
items:

- Press the :guilabel:`Add` button on the bottom right of the screen to add randomly-generated items.
- Press the :guilabel:`Edit` button on the top right to modify the list order, which the app persists in the {+realm+}.
- You can also swipe to delete items.

When you have items in the list, you can press one of the items to
navigate to the **ItemDetailsView**. This is where you can modify the
item name or mark it as a favorite:

- Press the text field in the center of the screen and type a new name. When you press Return, the item name should update across the app.
- You can also toggle its favorite status by pressing the heart toggle in the top right.

.. note::

   If you are using {+sync+}, you can see the changes you make sync to the
   backend and across devices.

Models
~~~~~~

A common {+service-short+} data modeling use case is to have "things" and
"containers of things". This app defines two related Realm object models: item
and group.

An item has two user-facing properties:

- A randomly generated-name, which the user can edit.
- An ``isFavorite`` boolean property, which shows whether the user "favorited" the item.

A group contains items. You can extend the group to have a name and an
association with a specific user, but that's out of scope of this guide.

.. literalinclude:: /examples/generated/swiftui/QuickStart.codeblock.models.swift
   :language: swift

Views and Observed Objects
~~~~~~~~~~~~~~~~~~~~~~~~~~

The entrypoint of the app is the **ContentView** class that derives from
``SwiftUI.App``. Depending on whether you've opted to use {+sync+}, Main
decides whether to show either the **SyncContentView** or the
**LocalOnlyContentView**.

.. literalinclude:: /examples/generated/swiftui/QuickStart.codeblock.content-view.swift
   :language: swift

The LocalOnlyContentView has an :swift-sdk:`@ObservedResults
<Structs/ObservedResults.html>` groups. This implicitly uses the default
{+realm+} to load all groups when the view appears.

.. tip::

   You can use a {+realm+} other than the default {+realm+} by passing
   an environment object from higher in the View hierarchy:
   
   .. code-block:: swift
   
      LocalOnlyContentView()
        .environment(\.realmConfiguration, Realm.Configuration( /* ... */ ))

This app only expects there to ever be one group. If there is a group in
the {+realm+}, the LocalOnlyContentView renders an **ItemsView** for
that group.

If there is no group already in the {+realm+}, then the
LocalOnlyContentView displays a ProgressView while it adds one. Because
the view observes the groups thanks to the ``@ObservedResults`` property
wrapper, the view immediately refreshes upon adding that first group and
displays the ItemsView.

.. literalinclude:: /examples/generated/swiftui/QuickStart.codeblock.local-only-content-view.swift
   :language: swift

The ItemsView receives the group from the parent view and stores it in
an :swift-sdk:`@ObservedRealmObject <Structs/ObservedRealmObject.html>`
property. This allows the ItemsView to "know" when the object has
changed regardless of where that change happened.

The ItemsView iterates over the group's items and passes each item to an
**ItemRow** for rendering as a list. 

To define what happens when a user deletes or moves a row, we pass the
``remove`` and ``move`` methods of the {+service-short+}
:swift-sdk:`List <Classes/List.html>` as the handlers of the respective
remove and move events of the SwiftUI List. Thanks to the
``@ObservedRealmObject`` property wrapper, we can use these methods
without explicitly opening a write transaction. The property wrapper
automatically opens a write transaction as needed.

.. literalinclude:: /examples/generated/swiftui/QuickStart.codeblock.items-view.swift
   :language: swift

Finally, the **ItemRow** and **ItemDetailsView** classes use the
``@ObservedRealmObject`` property wrapper with the item passed in from
above. These classes demonstrate a few more examples of how to use the
property wrapper to display and update properties.

.. literalinclude:: /examples/generated/swiftui/QuickStart.codeblock.item-row-and-details.swift
   :language: swift

MongoDB Realm and Sync
~~~~~~~~~~~~~~~~~~~~~~

If you opted to use Sync, the ContentView entrypoint displays the
**SyncContentView**.

The SyncContentView observes the Realm :swift-sdk:`app instance
<Extensions/App.html>`. The app instance is the interface to the MongoDB
Realm backend, which provides the user authentication required for Sync.
By observing the app instance, the SyncContentView can react when a user
logs in or out.

The SyncContentView also owns an optional :swift-sdk:`realm
<Structs/Realm.html>` wrapped in a :apple:`@State
<documentation/swiftui/state>` property wrapper. With Sync, we can only
open the {+realm+} once a user is logged in. Once logged in, we open the
realm asynchronously with :swift-sdk:`asyncOpen()
<Structs/Realm.html#/s:10RealmSwift0A0V9asyncOpen13configuration13callbackQueue0F0AC05AsyncD4TaskVAC13ConfigurationV_So17OS_dispatch_queueCys6ResultOyACs5Error_pGctFZ>`.
The SyncContentView refreshes when a {+realm+} is eventually opened and
assigned to the observable property ``@State var realm``.

.. tip::

   When opening a synced {+realm+} for the first time, it's a good idea
   to use ``asyncOpen()`` in order to download the {+realm+} completely
   from the backend before opening it. The device must be online to do
   this. If there was already a user on the device, you can use the
   regular :swift-sdk:`Realm.init(configuration:queue:)
   <Structs/Realm.html#/s:10RealmSwift0A0V13configuration5queueA2C13ConfigurationV_So012OS_dispatch_D0CSgtKcfc>`
   intializer to open the {+realm+}.

This view has three possible states:

- If the {+service-short+} app does not have a currently logged-in user, show the **LoginView**.
- Otherwise, if there is not already an open {+realm+}, show a loading indicator while opening one.
  Ensure there is one group object in the {+realm+}.
- Otherwise, there is a user and an open {+realm+}, so show the ItemsView for the group in the {+realm+}.
  Provide a **LogoutButton** the ItemsView can display on the top left of the navigation bar.

.. literalinclude:: /examples/generated/swiftui/QuickStart.codeblock.sync-content-view.swift
   :language: swift

User Authentication with MongoDB Realm
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The LoginView maintains some state in order to display an activity
indicator or error. It uses a reference to the Realm app instance passed
in from above to log in when the :guilabel:`Log in anonymously` button
is clicked.

.. tip::

   In the LoginView, you can implement :ref:`email/password
   authentication <ios-manage-email-password-users>` or :ref:`another
   authentication provider <authentication-providers>`. For simplicity,
   this example uses :ref:`Anonymous authentication
   <anonymous-authentication>`.

Once login is complete, the LoginView itself doesn't need to do anything
more. Because the parent view is observing the Realm app, it will notice
when the user authentication state has changed and decide to show
something other than the LoginView.

.. literalinclude:: /examples/generated/swiftui/QuickStart.codeblock.login-view.swift
   :language: swift

The LogoutButton works just like the LoginView, but logs out instead of
logging in:

.. literalinclude:: /examples/generated/swiftui/QuickStart.codeblock.logout-button.swift
   :language: swift

Summary
-------

- The guide demonstrates both local-only and {+sync+} use cases.
- Only provide views with the state they need. Avoid "wrapping" Realm where possible; use the SDK directly.

Feedback
--------

Did you find this guide helpful? Found an issue? Have a question? Please
let us know with the feedback form on the right side of the page!
