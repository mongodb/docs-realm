.. _swift-event-library:

=========================
Event Library - Swift SDK
=========================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------

The {+audit+} enables you to track a user's activity while using a 
Sync-enabled mobile application. The {+audit+} can record read and
write transactions. Developers can also configure custom events to record
button presses, the data displayed in the UI, or other important details.

After you enable {+audit+}, you can specify the events you want to record.
This means opening two {+realms+}: 

- The user {+realm+}, where the user does the reading and writing in the 
  client application
- The audit {+realm+}, where the {+audit+} records the scoped and custom events

The data from both {+realms+} syncs to your {+app+}. The client user never
interacts directly with the audit {+realm+} or its data; and the audit 
{+realm+} {+sync-short+} user can even be different from the user {+realm+}.

Because the {+audit+} generates a large amount of data:

- The client device must have enough capacity to store the data
- Expect {+sync+} usage for the audit {+realm+} to be higher than the reading
  and writing in the user {+realm+}
- The {+app+}'s backing Atlas cluster must have enough storage capacity to 
  handle the data generated by the {+audit+}

Enable Event Recording
----------------------

To enable event recording, set the :swift-sdk:`Audit.Configuration <>` property on
the :swift-sdk:`Realm.Configuration`.

You can initialize the ``AuditConfiguration`` in either of two ways:

- Use the default-initialized configuration when you don't need to specify details
- Pass additional parameters to customize the audit configuration

Default Audit Configuration
~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you don't need to specify particular parameters, you can use the 
default-initialized ``AuditConfiguration``:

.. literalinclude:: /examples/generated/code/start/Audit.codeblock.default-audit-configuration.swift
   :language: swift

Pass Parameters to Audit Configuration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can pass optional parameters to customize the ``AuditConfiguration``:

- ``metadata``: String dictionary of metadata fields to append to each audit event
- ``syncUser``: The user to use for syncing Audit Realm(s). If nil, defaults 
  to the user from the ``Realm.Configuration``.
- ``partitionPrefix``: String prefix to append to the audit partition value
- ``logger``: Custom logger to use for audit events. If nil, defaults to the
  logger from the audited {+realm+}.
- ``errorHandler``: Custom error handler to use when opening the audit realm. 
  If nil, defaults to the error handler from the audited {+realm+}.

.. literalinclude:: /examples/generated/code/start/Audit.codeblock.audit-configuration-with-params.swift
   :language: swift

Record Events
-------------

Interact with the Audit Realm
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

After you define your audit configuration, you can invoke the audit 
functionality with the new :swift-sdk:`audit <>` property on a 
:swift-sdk:`{+realm+} <Structs/Realm.html>`. This returns an ``Audit`` 
instance tied to that {+realm+}.

.. literalinclude:: /examples/generated/code/start/Audit.codeblock.invoke-audit-realm.swift
   :language: swift

Record Read or Write Events
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use :swift-sdk:`beginScope(activity: "some activity") <>` to begin recording
a new audit event with the given activity name. This records activities that 
occur within the scope of the audit event as read or write events.

- Read events: run queries and instantiate objects. When the scope ends, 
  the audit realm records these activities as read events.
- Write events: modify objects. When the scope ends, the audit realm records
  the initial state of the object, as well as the new values of any 
  properties that change durign the scope of the event.

.. literalinclude:: /examples/generated/code/start/Audit.codeblock.record-read-and-write-events.swift
   :language: swift

Using ``beginScope`` to record an audit event opens the audit {+realm+} if it 
is not already open. This can throw the same errors that opening a {+realm+}
can normally throw.

Use :swift-sdk:`endScope() <>` to finish recording the audit event. When
you end the recording, the {+audit+} saves the audit event to disk locally.
Then, if the device has a network connection, the {+audit+} asynchronously 
sends the data to the server.

You can pass an optional completion block to ``endScope()`` when you finish 
recording. The SDK calls this block when the audit data has been successfully 
persisted - not when the audit realm upload has completed.

Record Custom Events
~~~~~~~~~~~~~~~~~~~~

The {+audit+} lets you record button clicks or other events that do not
involve database reads and writes. Use :swift-sdk:`recordAuditEvent <>`
to record a custom event. This function takes these parameters:

- ``activity``: the activity name. This is an arbitrary string, such as 
  "user registration."
- ``eventType``: the type of event. This is an arbitrary string, such as 
  "pressed Submit button."
- ``data``: an optional data payload for the event. If supplied, the 
  string is UTF-8 encoded.
- ``completion``: an optional completion handler. The {+audit+} calls 
  this completion block once the event has been saved to the audit 
  {+realm+}, or if an error occurs. A nil error indicates success.

A custom event doesn't have a scope like read and write events. Instead,
recording a custom event is more analogous to firing a trigger.

.. literalinclude:: /examples/generated/code/start/Audit.codeblock.record-custom-events.swift
   :language: swift

Event Object Serialization
--------------------------

JSON Object Serialization
~~~~~~~~~~~~~~~~~~~~~~~~~

The {+audit+} converts each audit event object to a JSON object. Most
:ref:`{+client-database+} types <ios-supported-property-types>` have an 
easily inferred JSON representation. For example, a {+client-db-short+} 
String property becomes a JSON String.

This is how the {+audit+} represents the types that do not have a direct 
JSON analog:

.. list-table::
   :widths: 20 80

   * - Date
     - Encoded to a string in :wikipedia:`ISO 8601-1:2019 format <ISO_8601>`.
   * - Data
     - Excluded entirely from the audit event.
   * - UUID
     - Encoded to a :rfc:`4122`-compliant string.
   * - ObjectID
     - Encoded to our :manual:`ObjectID <reference/method/ObjectId>` string representation.
   * - Decimal128
     - Encoded to a string, not a number. JSON numbers are officially infinite-
       precision, but are rarely actually implemented as such.
   * - List
     - Encoded as an array.
   * - Set
     - Encoded as an array.
   * - Dictionary
     - Encoded as an object.
   * - Embedded objects
     - Encoded as an object.

Non-embedded object links are encoded as the primary key of the target. In
read events, if the link is followed, this expands to the full object. If
the link is not followed, this remains a primary key.

Customize Event Serialization
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can customize JSON serialization for audit event objects. To customize
the payload of audit events, use the :swift-sdk:`CustomAuditRepresentable <>` 
protocol.

When an object conforms to ``CustomAuditRepresentable``, the {+audit+} 
serializes objects by:

- Constructing an accessor object
- Calling ``customAuditRepresentation`` on that accessor object
- Serializing the result instead of the original object

To conform to ``CustomAuditRepresentable``, your object must implement a
:swift-sdk:`customAuditRepresentation <>` function that defines your 
customized serialization.

.. literalinclude:: /examples/generated/code/start/Audit.codeblock.custom-audit-representable.swift
   :language: swift

Audit Realm File Size
---------------------

The audit {+realm+} can grow quite large if the device is offline for an 
extended time. 

To compensate for this, the {+audit+} automatically splits audit data into 
multiple partitions as needed. When a partition reaches its maximum size,
the {+audit+} closes the audit {+realm+} and automatically begins writing
to a new partition.

The {+audit+} checks whether the user has any unsynced partitions. If they 
do, the {+audit+} opens one, uploads the data, and then closes the file
and deletes it. This repeats until the user has no unsynced partitions.

Event Library Reference
-----------------------

Events
~~~~~~

An audit event object contains:

.. list-table::
   :widths: 20 20 60

   * - Type of Event
     - ``event``
     - Optional string. ``read`` or ``write`` for scoped audit events, or
       an arbitrary string for custom events.

   * - Event Scope
     - ``scope``
     - Optional string. The scope name passed to ``beginScope()`` to begin
       recording the event, or an arbitrary string for custom events.

   * - Timestamp
     - ``timestamp``
     - Device local time when the auditable event scope is ended and the 
       data is committed, *or* the time when the event hits the server.

   * - Audit Data
     - ``data``
     - The audit payload. This is a JSON blob for scoped events, or an 
       arbitrary string for custom events.

   * - Audit Metadata
     - ``metadata key`` (string)
     - An optional metadata dictionary. When this dictionary contains keys 
       and values, the key becomes a field name in the audit object, and
       the value is stored in that field for every audit event.

Event Payload
~~~~~~~~~~~~~

Each audit event contains a payload in the ``data`` property that captures
the current state of the objects being read or written to.

Payloads for read or write events are UTF-8 JSON blobs compressed with DEFLATE.
Payloads for custom events can be whatever the developer desires, including nil.

.. important::

   Because the payload captures the current state of the objects being read or
   written to, this produces a very large amount of data. However, this must 
   be done on the client rather than the server, as the exact data that the
   user views may never exist server-side. In practice, this means that the
   device must have the capacity to store a large amount of data if it goes
   offline. Additionally, {+sync+} usage for the audit realm may be much 
   higher than for the reading and writing the user does in the user
   realm.
