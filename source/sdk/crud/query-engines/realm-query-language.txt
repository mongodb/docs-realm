.. _realm-query-language:
.. _rql:

==========================
Realm Query Language (RQL)
==========================

.. meta::
  :description: Use Realm Query Language (RQL) with Atlas Device SDK methods to retrieve objects from the database.
  :keywords: Realm, C++ SDK, Flutter SDK, Kotlin SDK, .NET SDK, Java SDK, Node.js SDK, code example

.. facet::
  :name: genre
  :values: reference

.. facet::
  :name: programming_language
  :values: cpp, csharp, dart, java, javascript/typescript, kotlin

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 3
   :class: singlecol

.. tabs-selector:: drivers

Realm Query Language (RQL) is a string-based query language that you can use
to construct queries for Atlas Device SDK. Each SDK provides language-specific
filter or query methods that pass the queries to the Realm database query
engine. For more information about SDK-specific query methods, refer to
:ref:`sdks-crud-read`.

.. important:: Swift SDK Does Not Support Realm Query Language (RQL)

   The Swift SDK does *not* support querying with Realm Query Language.
   Instead, it uses NSPredicate to query a database. For more information, refer
   to :ref:`Type-Safe and NSPredicate Queries (Swift SDK) <sdks-filter-data-swift>`.

The following SDKs also support language-specific idiomatic APIs for querying
databases:

- :ref:`Fluent Interface (Java SDK) <java-filter-data>`
- :ref:`LINQ (.NET SDK) <dotnet-linq>`

In addition to using RQL in your client code, you can also use RQL in
:ref:`Realm Studio <realm-studio>` to browse for data.

Examples on This Page
---------------------

Most of the examples on this page use a simple data set for a to-do list app
that include the following database object types:

- ``Item``: Each item object has a name, assignee's name, and completed flag.
  There is also an arbitrary number for priority (where higher is more
  important) and a count of minutes spent working on it.
- ``Project``: Each project object has zero or more ``Items`` and an optional
  quota for minimum number of to-do items expected to be completed.

.. include:: /includes/sdk-examples/query/rql-example-data-model.rst


Query Syntax
------------

Realm Query Language syntax is based on `NSPredicate
<https://developer.apple.com/documentation/foundation/nspredicate>`__.

Queries evaluate a predicate for every object in the collection being queried.
If the predicate resolves to ``true``, the results collection includes the
object.

Realm Query Language uses expressions and predicates to filter objects. Filters
consist of expressions within a predicate that evaluate to ``true`` or
``false``.

Each expression contains the following elements:

- **Property name**: The name of the object property to evaluate.
- **Operator** and **argument expression**: A valid operator and *up to two*
  argument expressions. For example, in the expression ``A + B``, the entirety
  of ``A + B`` is an expression, but ``A`` and ``B`` are also argument
  expressions to the operator ``+``.
- **Value**: The value, such as a string (``'hello'``) or a number (``5``), to
  use in the evaluation.

.. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.predicate.ts.rst

Expressions can be combined with :ref:`logical operators <rql-logical-operators>`
to create compound predicates.

Realm Query Language also supports the following special predicates:

- ``TRUEPREDICATE`` - Always evaluates to ``true`` (returns all objects).
- ``FALSEPREDICATE`` - Always evaluates to ``false`` (returns no objects).


.. _rql-parameterized-queries:

Parameterized vs. Serialized Queries
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can format queries in serialized or parameterized format.

- Serialized queries pass values directly in the expression.

  .. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.serialized-query.ts.rst

- Parameterized queries pass interpolated variables as additional
  arguments. The syntax for interpolated variables is
  ``$<int>``, starting at ``0`` and incrementing for each additional variable.

  .. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.parameterized-query.ts.rst

The following table shows how a query should be formatted when serialized and
parameterized for the specific data types:

.. list-table::
  :header-rows: 1
  :widths: 15 25 25 35

  * - Type
    - Parameterized Example
    - Serialized Example
    - Note

  * - :ref:`Nil <rql-nil-type>`
    - "assignee == $0", null
    - "assignee == nil"
    - For parameterized queries, ``null`` maps to each SDK's respective null
      pointer.

  * - Boolean
    - "setting == $0", false
    - "setting == false"
    - ``true`` or ``false`` values.

  * - :ref:`String <rql-string-operators>`
    - "name == $0", "George"
    - "name == 'George'"
    - Applies to ``string`` and ``char`` data type.

  * - :ref:`Number <rql-arithmetic-operators>`
    - "age > $0", 5.50
    - "age > 5.50"
    - Applies to ``int``, ``short``, ``long``, ``double``, ``Decimal128``, and
      ``float`` data types.

  * - :ref:`Date <rql-date-operators>`
    - "date < $0", dateObject
    - "date < 2021-02-20\@17:30:15:0"
    - For parameterized queries, you must pass in a date object.
      For serialized queries, the representation can be a
      :ref:`supported Date format <rql-date-operators>` or a parameterized
      ``Date`` object.

  * - :ref:`ObjectID <rql-objectid-uuid-operators>`
    - "_id == $0", oidValue
    - "_id == oid(507f1f77bcf86cd799439011)"
    - For parameterized queries, you must pass in an ObjectId.
      For serialized queries, the string representation is ``oid(<ObjectId String>)``.

  * - :ref:`UUID <rql-objectid-uuid-operators>`
    - "id == $0", uuidValue
    - "id == uuid(d1b186e1-e9e0-4768-a1a7-c492519d47ee)"
    - For parameterized queries, you must pass in a UUID.
      For serialized queries, the string representation is ``uuid(<UUID String>)``.

  * - Binary
    - "value == $0", "binary"
    - "value == 'binary'"
    - For ASCII characters, RQL serializes the binary value like a string,
      with quotes. For non-printable characters,
      RQL serializes the binary to a base 64 value.

  * - :ref:`Collection <rql-list-queries>`
    - "ANY items.name == {$0, $1}", "milk", "bread"
    - "ANY items.name == {'milk', 'bread'}"
    - Applies to collections, dictionaries, lists, and sets. Use a parameterized
      value for each member of the list.

  * - RealmObject
    - "ANY items == $0", obj("Item", oid(6489f036f7bd0546377303ab))
    - "ANY items == obj('Item', oid(6489f036f7bd0546377303ab))"
    - To pass in a RealmObject, you need the class and primary key of the
      object.

.. _rql-dot-notation:

Dot Notation
~~~~~~~~~~~~

You can use **dot notation** to refer to child properties of an object,
including the properties of embedded objects and relationships:

.. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.dot-notation.ts.rst

You can also chain these notations for nested properties.
For example, each Project has a ``projectLocation`` property that
refers to an Office object, which itself contains an embedded object
property ``address``. You can chain dot notations to query the deeply nested
``zipcode`` property of an embedded address:

.. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.deep-dot-notation.ts.rst


.. _rql-nil-type:

Nil Type
~~~~~~~~

Realm Query Language includes the ``nil`` type to represent a null pointer.
You can either reference ``nil`` directly in your queries or with a
parameterized query. If you're using a parameterized query, each SDK maps its
respective null pointer to ``nil``.

.. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.nil-type.ts.rst


.. _rql-operators:

General Operators
-----------------

.. _rql-aggregate-operators:

Aggregate Operators
~~~~~~~~~~~~~~~~~~~

Use aggregate operators to traverse a collection and reduce it to a single
value.

.. list-table::
   :header-rows: 1
   :widths: 20 80

   * - Operator
     - Description

   * - | ``@avg``
     - Evaluates to the average value of a given numerical property across
       a collection. ``null`` values are ignored.

   * - | ``@count``
     - Evaluates to the number of objects in the given collection.

   * - | ``@max``
     - Evaluates to the highest value of a given numerical property
       across a collection. ``null`` values are ignored.

   * - | ``@min``
     - Evaluates to the lowest value of a given numerical property
       across a collection. ``null`` values are ignored.

   * - | ``@sum``
     - Evaluates to the sum of a given numerical property across a collection.
       ``null`` values are ignored.

The following example uses aggregate operators to find projects whose ``items``
collection property meets certain criteria:

.. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.aggregate-operators.ts.rst

.. _rql-arithmetic-operators:

Arithmetic Operators
~~~~~~~~~~~~~~~~~~~~

Use arithmetic operators to perform basic arithmetic in an expression when
evaluating numeric data types, including object properties.

.. list-table::
   :header-rows: 1
   :widths: 20 80

   * - Operator
     - Description

   * - | ``*``
     - Multiplication.
   * - | ``/``
     - Division.
   * - | ``+``
     - Addition.
   * - | ``-``
     - Subtraction.
   * - | ``()``
     - Group expressions together.

The following example uses arithmetic operators on Item object properties
containing numeric values:

.. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.basic-arithmetic.ts.rst

.. _rql-comparison-operators:

Comparison Operators
~~~~~~~~~~~~~~~~~~~~

Use comparison operators to compare values of matching data types. String values
are compared :wikipedia:`lexicographically <Alphabetical_order>`.

.. list-table::
   :header-rows: 1
   :widths: 20 80

   * - Operator
     - Description

   * - ``BETWEEN {X, Y}``
     - Evaluates to ``true`` if the left-hand expression (``X``)
       is between or equal to the right-hand expression (``Y``) range.

   * - | ``==``, ``=``
     - Evaluates to ``true`` if the left-hand expression is equal to the
       right-hand expression.

   * - | ``>``
     - Evaluates to ``true`` if the left-hand expression is greater than the
       right-hand expression. For dates, this evaluates to ``true`` if the
       left-hand date is later than the right-hand date.

   * - | ``>=``
     - Evaluates to ``true`` if the left-hand expression is greater than or
       equal to the right-hand expression. For dates, this evaluates to
       ``true`` if the left-hand date is later than or the same as the
       right-hand date.

   * - | ``IN``
     - Evaluates to ``true`` if the left-hand expression is in the
       right-hand list. This is equivalent to and used as a shorthand
       for ``== ANY`` :ref:`collection operator <rql-collection-operators>`.

   * - | ``<``
     - Evaluates to ``true`` if the left-hand numerical or date expression
       is less than the right-hand numerical or date expression. For dates, this
       evaluates to ``true`` if the left-hand date is earlier than the
       right-hand date.

   * - | ``<=``
     - Evaluates to ``true`` if the left-hand numeric expression is less than
       or equal to the right-hand numeric expression. For dates, this evaluates
       to ``true`` if the left-hand date is earlier than or the same as the
       right-hand date.

   * - | ``!=``, ``<>``
     - Evaluates to ``true`` if the left-hand expression is not equal
       to the right-hand expression.

The following example uses comparison operators to find to-do items whose
property values match certain criteria:

.. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.comparison-operators.ts.rst

.. important:: Types Must Match

   The type on both sides of the operator must be equivalent. For
   example, comparing an ObjectId with string will result in a precondition
   failure with a message similar to the following:

   .. code-block::
      :copyable: false

      "Expected object of type object id for property 'id' on object of type
      'User', but received: 11223344556677889900aabb (Invalid value)"

   You can compare any numeric type with any other numeric type,
   including decimal, float, and Decimal128.


.. _rql-logical-operators:

Logical Operators
~~~~~~~~~~~~~~~~~

Use logical operators to create compound predicates.

.. list-table::
   :header-rows: 1
   :widths: 20 80

   * - Operator
     - Description

   * - | ``AND``
       | ``&&``
     - Evaluates to ``true`` if both left-hand and right-hand expressions are
       ``true``.

   * - | ``NOT``
       | ``!``
     - Negates the result of the given expression.

   * - | ``OR``
       | ``||``
     - Evaluates to ``true`` if either expression returns ``true``.

The following example uses logical operators to combine multiple predicates:

.. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.logical-operators.ts.rst


.. _rql-sort-distinct-limit:

Results Operators
~~~~~~~~~~~~~~~~~

Use the sort, distinct, and limit operators to shape your query results
collection. You can combine these operators in a single query across multiple
properties. Operators are applied in the order they appear in the query.

.. list-table::
   :header-rows: 1
   :widths: 20 80

   * - Suffix
     - Description

   * - ``SORT``
     - Sort the results collection in the specified order for one or more
       comma-separated properties. The SDK applies the sort operation for each
       property in order, one at a time. Specify the sort order for each
       property as either:

       - ``ASC`` (ascending)
       - ``DESC`` (descending)

   * - ``DISTINCT``
     - Remove duplicates of the one or more comma-separated properties from the
       results collection. The SDK applies all distinct operations as a single
       AND condition, where duplicates must match *all* specified properties.

   * - ``LIMIT``
     - Limit the results collection to the specified number.

The following example finds all incomplete items, then shapes the returned
results:

.. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.sort-distinct-limit.ts.rst

.. important:: Order Matters

    The SDK executes queries in order. This includes the order of any ``SORT``,
    ``DISTINCT``, and ``LIMIT``  operators in the query *and* the order of any
    properties within those operators. This can greatly impact the results
    returned. For example, sorting a query before limiting it can return very
    different results than sorting *after* limiting it.

    .. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.sort-distinct-limit-order-matters.ts.rst

Type-Specific Operators
-----------------------

.. _rql-collection-operators:

Collection Operators
~~~~~~~~~~~~~~~~~~~~

A collection operator lets you query list properties within a collection of
objects. Collection operators filter a collection by applying a predicate to
every element of a given list property of the object. If the predicate returns
true, the object is included in the output collection.

.. list-table::
   :header-rows: 1
   :widths: 20 80

   * - Operator
     - Description

   * - ``ALL``
     - Returns objects where the predicate evaluates to ``true`` for all objects
       in the collection.

   * - ``ANY``, ``SOME``
     - Returns objects where the predicate evaluates to ``true`` for any objects
       in the collection. ``ANY`` is the default operator for list comparisons.

   * - ``NONE``
     - Returns objects where the predicate evaluates to false for all objects
       in the collection.

The following example uses collection operators to find projects whose ``items``
collection property meets certain criteria

.. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.set-operators.ts.rst


.. _rql-dictionary-operators:

Dictionary Operators
~~~~~~~~~~~~~~~~~~~~

Use dictionary operators in combination with
:ref:`comparison operators <rql-comparison-operators>` to filter objects
based on dictionary keys and values.

.. list-table::
   :header-rows: 1
   :widths: 40 60

   * - Operator
     - Description

   * - ``@values``
     - Returns objects that have a specified dictionary value.

   * - ``@keys``
     - Returns objects that have a specified dictionary key.

   * - ``@size``, ``@count``
     - The number of elements in a dictionary.

   * - ``Dictionary['key']``
     - The value of a dictionary key.

   * - ``ALL | ANY | NONE <property>.@type``
     - Checks if the dictionary contains properties of certain type.

The following example uses dictionary operators with comparison operators to
find projects based on the ``comments`` dictionary property:

.. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.dictionary-operators.ts.rst


.. _rql-string-operators:

String Operators
~~~~~~~~~~~~~~~~

Use string operators or :ref:`comparison operators <rql-comparison-operators>`
to filter objects based on string values. SDKs evaluate string values
:wikipedia:`lexicographically <Alphabetical_order>`.

.. list-table::
   :header-rows: 1
   :widths: 20 80

   * - Operator or Modifier
     - Description

   * - | ``BEGINSWITH``
     - Evaluates to ``true`` if the left-hand string begins with
       the right-hand string. This is similar to ``contains``,
       but only matches if the right-hand string is found
       at the beginning of the left-hand string.

   * - | ``CONTAINS``
     - Evaluates to ``true`` if the right-hand string
       is found anywhere in the left-hand string.

   * - | ``ENDSWITH``
     - Evaluates to ``true`` if the left-hand string ends
       with the right-hand string. This is similar to ``contains``,
       but only matches if the left-hand string is found
       at the very end of the right-hand string.

   * - | ``LIKE``
     - Evaluates to ``true`` if the left-hand string
       matches the right-hand string wildcard string. A wildcard string
       expression is a string that uses normal characters with two special
       wildcard characters:

       - The ``*`` wildcard matches zero or more of any character
       - The ``?`` wildcard matches any character.

       For example, the wildcard string "d?g" matches "dog",
       "dig", and "dug", but not "ding", "dg", or "a dog".

   * - | ``[c]``
     - Modifier that indicates a string value is *not* case sensitive. String
       values are case sensitive by default.

The following example uses string and comparison operators to find projects
based on the project name:

.. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.string-operators.ts.rst

.. tip:: String Values are Case Sensitive

  String values are case sensitive by default. Use the ``[c]`` modifier to
  specify that values are *not* case sensitive.

  For example, ``"name CONTAINS[c] $0", "da"`` would return "David" and "Ida",
  but ``"name CONTAINS $0", "da"`` would only return "Ida".


.. _rql-type-operator:

Type Operator
~~~~~~~~~~~~~

.. note:: Only Supported for Mixed Data Types and Dictionaries

  You can currently only use the ``@type`` operator with mixed data types and
  dictionary properties.

Check the data type of a mixed type or dictionary property using the
``@type`` operator. Evaluate the property against a string representation of the
data type name using string comparison operators. For information on how each
SDK language's data types map to database-specific data types, refer to
:ref:`sdks-supported-data-types`.

.. list-table::
   :header-rows: 1
   :widths: 20 80

   * - Operator
     - Description

   * - ``@type``
     - Check if type of a mixed type or dictionary property is the specified
       data type represented as a string.

       Use ``==`` and ``!=`` to compare equality.

The following example uses the ``@type`` operator to find projects
whose mixed data type ``additionalInfo`` property type matches specific
criteria:

.. include:: examples/generated/node/v12/formatted/realm-query-language.test.snippet.type-operator.ts.rst


Type-Specific Queries
---------------------

.. _rql-date-operators:

Date Queries
~~~~~~~~~~~~

Use :ref:`comparison operators <rql-comparison-operators>` to query date types.

Specify dates in the following formats:

- As a date in UTC, with the date and time separated by ``@`` or ``T``:
  ``YYYY-MM-DD@HH:mm:ss:nnnnnnnnnn``
  (year-month-day@hours:minutes:seconds:nanoseconds), UTC.
- As a time in seconds since the :wikipedia:`Unix epoch <Unix_time>`:
  ``Ts:n``
  (``T`` designates the start of the time, ``s`` is the number of seconds, and
  ``n`` is the number of nanoseconds).

.. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.date-alt-representation.ts.rst

The following example uses a parameterized query to find items based on a new
``dateCreated`` property that populates when an item is marked as complete:

.. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.date-parameterized-query.ts.rst

.. tip:: Parameterize Date Queries

    We recommend using a :ref:`parameterized query <rql-parameterized-queries>`
    to pass the date data type from the SDK language you are using to your
    query.


.. _rql-fts:

Full Text Search (FTS) Queries
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Perform boolean match word searches to query on properties that have a full-text
search (FTS) annotation. For information on enabling FTS on a property, refer to
:ref:`sdks-fts-property`.

.. list-table::
   :header-rows: 1
   :widths: 20 80

   * - Operator
     - Description

   * - ``TEXT``
     - Evaluates to ``true`` if the left-hand FTS-enabled string property
       matches the right-hand string or wildcard string. A wildcard string
       expression is a string that uses normal characters with two special
       wildcard characters:

       - The ``*`` wildcard matches zero or more of any character that occur
         after the string.
       - The ``-`` wildcard matches all characters for exclusion from results.

Query strings are converted to tokens by a tokenizer using the following rules:

- Tokens can only consist of characters from ASCII and the Latin-1 supplement
  western languages). All other characters are considered whitespace.
- Strings split by a hyphen (``-``) are split into two tokens. For example,
  ``full-text`` splits into ``full`` and ``text``.
- Tokens are diacritics insensitive and case insensitive.

You can search for entire words or phrases, or limit your results with the
following wildcard characters:

- Exclude results for a word by placing the ``-`` character in front of the word.
- Specify prefixes by placing the ``*`` wildcard at the end of a prefix. Suffix
  searching is not currently supported.

The following example uses the ``TEXT`` operator to find items based on their
FTS-enabled ``name`` property:

.. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.rql-fts.ts.rst


.. _rql-geospatial:

Geospatial Queries
~~~~~~~~~~~~~~~~~~

Use the ``geoWithin`` operator to query geospatial data. For more information on
defining geospatial data, refer to :ref:`sdks-define-geospatial-object`.

.. list-table::
   :header-rows: 1
   :widths: 20 80

   * - Operator
     - Description

   * - ``geoWithin``
     - Returns objects where the latitude/longitude pair in a custom embedded
       object's ``coordinates`` property
       is contained within a specified geospatial shape.

       The following geospatial shapes are supported:

       - ``GeoCircle``
       - ``GeoBox``
       - ``GeoPolygon``

A geospatial query consists of:

- An object with a property containing the embedded geospatial data.
- A defined geospatial shape to set the boundary for the query:

  - ``GeoCircle``
  - ``GeoBox``
  - ``GeoPolygon``

The query evaluates ``true`` if the coordinates of the embedded property are
within the boundaries of the geospatial shape.

The following example compares the coordinates of the embedded ``location``
property against the boundaries of the ``GeoCircle`` shape named
``smallCircle``:

.. include:: /examples/generated/node/v12/formatted/geospatial.test.snippet.rql-geospatial.js.rst

.. important:: Geospatial Queries Do Not Support Parameterized Queries

   You cannot use :ref:`parameterized queries <rql-parameterized-queries>` with
   geospatial data.


.. _rql-backlinks:

Inverse Relationship Queries (Backlinks)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can query an object's :ref:`inverse relationship <sdks-relationships>` to
another object through its **backlink**. Backlinks use the to-one
and to-many relationships defined in your object schemas but reverse the
direction. Every relationship that you define in your schema implicitly has a
corresponding backlink.

.. list-table::
   :header-rows: 1
   :widths: 20 80

   * - Operator
     - Description

   * - ``@links``
     - Accesses the inverse relationship specified by the object type and
       property name (``@links.<ObjectType>.<PropertyName>``).
   * - ``@count``
     - The number of elements in a backlink collection. You can use the
       ``@count`` operator directly on ``@links`` to query the count of all
       relationships that point to an object.

You can access an inverse relationship:

- Using the ``@links.<ObjectType>.<PropertyName>`` syntax, where
  ``<ObjectType>`` and ``<PropertyName>`` refer to a specific property on an
  object type that references the queried object type.

  .. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.backlinks-atLinks.ts.rst

- Using the ``linkingObjects`` property to explicitly include the backlink in
  your data model. This lets you reference the backlink through an assigned
  property name using :ref:`dot notation <rql-dot-notation>`.

  .. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.backlinks-linkingObjects.ts.rst

The result is treated like a collection and supports :ref:`collection operators
<rql-collection-operators>` and :ref:`aggregate operators
<rql-aggregate-operators>`.

The following examples find items based on the projects they belong to through
the ``@links`` operator or the ``projects`` property:

.. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.backlinks-collection-operators.ts.rst


.. _rql-list-queries:

List Comparison Queries
~~~~~~~~~~~~~~~~~~~~~~~

Use :ref:`comparison operators <rql-comparison-operators>` and
:ref:`collection operators <rql-collection-operators>` to filter based
on lists of data. You can compare any type of valid list, including:

- Collections of objects, which let you filter against other data
  in the database.

  .. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.list-comparisons-collection.ts.rst

- Lists defined directly in the query, which let you filter against
  static data. You define static lists as a comma-separated list of
  literal values enclosed in opening (``{``) and closing (``}``) braces.

  .. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.list-comparisons-static.ts.rst

- Native list objects passed in a :ref:`parameterized expression
  <rql-parameterized-queries>`, which let you pass application data
  directly to your queries.

  .. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.list-comparisons-parameterized.ts.rst

.. note:: Defaults to ``ANY``

   If you do not define a collection operator, a list expression defaults
   to the ``ANY`` operator.

   .. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.equivalent-lists-any-operator.ts.rst

The following table demonstrates how collection operators interact with
lists and comparison operators:

.. list-table::
   :widths: 45 10 45

   * - Expression
     - Match?
     - Reason

   * - ``ANY {1, 2, 3} > ALL {1, 2}``
     - true
     - A value on the left (3) is greater than some value on the right (both 1
       and 2)

   * - ``ANY {1, 2, 3} == NONE {1, 2}``
     - true
     - 3 does not match either of 1 or 2

   * - ``ANY {4, 8} == ANY {5, 9, 11}``
     - false
     - Neither 4 nor 8 matches any value on the right (5, 9 or 11)

   * - ``ANY {1, 2, 7} <= NONE {1, 2}``
     - true
     - A value on the left (7) is not less than or equal to both 1 and 2

   * - ``ALL {1, 2} IN ANY {1, 2, 3}``
     - true
     - Every value on the left (1 and 2) is equal to 1, 2 or 3

   * - ``ALL {3, 1, 4, 3} == NONE {1, 2}``
     - false
     - 1 matches a value in the NONE list (1 or 2)

   * - ``ALL {} in ALL {1, 2}``
     - true
     - An empty list matches all lists

   * - ``NONE {1, 2, 3, 12} > ALL {5, 9, 11}``
     - false
     - 12 is bigger than all values on the right (5, 9, and 11)

   * - ``NONE {4, 8} > ALL {5, 9, 11}``
     - true
     - 4 and 8 are both less than some value on the right (5, 9, or 11)

   * - ``NONE {0, 1} < NONE {1, 2}``
     - true
     - 0 and 1 are both less than none of 1 and 2


.. _rql-subqueries:

List Subqueries
~~~~~~~~~~~~~~~

Use the ``SUBQUERY()`` predicate function to iterate through list properties
with an additional query. Subqueries are useful when you need to match objects
in a list property based on multiple conditions.

Subqueries use the following syntax:

``SUBQUERY(<collection>, $<variableName>, <predicate>).@count``

.. list-table::
   :header-rows: 1
   :widths: 20 80

   * - Operator
     - Description

   * - ``SUBQUERY()``
     - Returns list objects for the specified collection where the predicate
       evaluates to ``true``. Contains the following parameters:

       - ``collection``: The name of the list property to iterate through. This
         must be a list of objects, not a list of primitive types.
       - ``variableName``: A variable name of the element to use in the
         subquery, prefixed with ``$``.
       - ``predicate``: The subquery predicate. Use the variable specified by
         ``variableName`` to refer to the currently-iterated element.

   * - ``@count``
     - The number of objects in the subquery results collection. This is
       required for subquery filters. You can use the count of the subquery
       result as you would any other number in a valid expression.

The following example uses subquery filters to find projects based on the
``items`` collection property using the ``$item`` variable name:

.. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.subquery.ts.rst

.. tip:: Compare Count to ``0`` to Return All Matching Objects

   The ``@count`` aggregate operator returns the number of objects in the
   subquery results collection. You can compare the count with the number ``0``
   to return all matching objects.


.. _rql-objectid-uuid-operators:

ObjectId and UUID Queries
~~~~~~~~~~~~~~~~~~~~~~~~~

Use :ref:`comparison operators <rql-comparison-operators>` to compare
:manual:`BSON ObjectIds </reference/method/ObjectId>` and
:manual:`UUIDs </reference/method/UUID/>` for equality. These data types are
often used as primary keys.

You can use pass ``ObjectId`` and ``UUID`` values either as parameterized query
arguments or to the ``oid()`` or ``uuid()`` predicate functions, respectively.

.. list-table::
   :header-rows: 1
   :widths: 30 70

   * - Operator
     - Description

   * - | ``oid(<ObjectId String>)``
     - The string representation of the ``ObjectID`` to evaluate.

   * - | ``uuid(<UUID String>)``
     - The string representation of the ``UUID`` to evaluate.

The following examples use equality comparison operators to find items based on
their ``_id`` property:

.. include:: /examples/generated/node/v12/formatted/realm-query-language.test.snippet.oid.ts.rst


.. _flexible-sync-rql-limitations:

Device Sync Subscription Queries
---------------------------------

If your app uses Atlas :ref:`Device Sync<realm-sync-get-started>`, you can use
Realm Query Language to construct your :ref:`sync subscription
queries<sdks-manage-sync-subscriptions>`. However, App Services does not support
all RQL operators or functionality in a subscription query.

Device Sync does *not* support the following in a subscription query:

- :ref:`Aggregate operators <rql-aggregate-operators>` (``@avg``,
  ``@count``, ``@max``, ``@min``, or ``@sum``)
- :ref:`Results operators <rql-sort-distinct-limit>` (``DISTINCT``,
  ``SORT``, or ``LIMIT``)
- :ref:`List comparisons <rql-list-queries>` (for example,
  ``"{'comedy', 'horror', 'suspense'} IN genres"``)
- Querying for embedded objects or links (for example, ``obj1.field == "foo"``).

However, you can use the following:

- You can use ``@count`` for array fields.
- You can query lists using the ``IN`` operator:

  .. code-block:: javascript

    // Query a constant list for a queryable field value
    "priority IN { 1, 2, 3 }"

    // Query an array-valued queryable field for a constant value
    "'comedy' IN genres"

.. tip:: Case-Insensitive Queries Not Recommended

  Although :ref:`case-insensitive string queries<rql-string-operators>` (using
  the ``[c]`` modifier) are supported in sync queries, they do not use indexes
  effectively and can lead to performance problems. As a result, they are not
  recommended.

Additionally, note the following if you are using an :ref:`indexed queryable
field<fs-indexed-queryable-fields>` in your app:

- Every query must include the indexed queryable field.
- Every query must directly compare the indexed queryable field
  against a constant using an ``==`` or ``IN`` operator at least once.
- You can optionally include an ``AND`` comparison as well.

