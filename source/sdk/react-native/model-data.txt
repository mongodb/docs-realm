.. _react-native-model-data:
.. _react-native-schemas-overview:

=============================
Model Data - React Native SDK
=============================

.. toctree::
   :titlesonly:

   Define an Object Model </sdk/react-native/model-data/define-a-realm-object-model>
   Relationships & Embedded Objects </sdk/react-native/model-data/relationships-and-embedded-objects>
   Change an Object Model </sdk/react-native/model-data/change-an-object-model>
   Data Types </sdk/react-native/model-data/data-types>

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

.. _react-native-object-types:
.. _react-native-object-schemas:
.. _react-native-object-models:

Every Realm object conforms to a specific **object type**. Object types are
classes you define that contain the properties and :ref:`relationships <react-native-relationships>`
for objects of that type using a pre-defined schema.

Realm guarantees that all objects in a realm conform to the schema for their
object type and validates objects whenever they're created, modified, or deleted.

Realm objects are fundamentally similar to a common JavaScript object but they
also bring along a few additional features like schema validation and :ref:`live
queries <react-native-live-queries>`.

The React Native SDK memory maps Realm objects directly
to native JavaScript objects, which means there's no need to use a special data
access library, such as an :wikipedia:`ORM <Object-relational_mapping>`.
Instead, you can work with Realm objects as you would any other object.

.. _react-native-realm-schema:

Realm Schema
~~~~~~~~~~~~

A **realm schema** is a list of valid :ref:`object schemas
<react-native-object-schemas>` that a realm may contain. Every Realm object must conform
to an object type that's included in its realm's schema.

If a realm already contains data when you open it, Realm
validates each object to ensure that an object schema was provided for its type
and that it meets all of the constraints specified in the schema.

Using ``@realm/react``, you define a realm schema by passing individual object
schemas to ``RealmProvider`` or ``createRealmContext()``.

.. literalinclude:: /examples/generated/react-native/js/RealmConfig.snippet.create-realm-context.js
   :language: javascript
   :emphasize-lines: 8

.. _react-native-model-unstructured-data:

Model Unstructured Data
-----------------------

.. versionadded:: ``realm@12.9.0``

Starting in SDK version 12.9.0, you can
:ref:`define nested collections
of mixed data <react-native-nested-collections-mixed>`
within a  ``mixed`` property.

The ability to nest collections of mixed data enables you to define data
that doesn't otherwise conform to an expected schema, including data with
variable structure or data whose shape or type is not known at runtime.
For example, you might have highly variable user-created objects, event logs,
or survey response data that are collected and stored in a variety of JSON
formats. This approach allows you to :ref:`react to changes <react-native-collection-listener>`
in the nested data and to update specific elements, but it is less
performant than using a structured schema or serializing JSON blobs
into a single string property.

To model unstructured data in your schema using collections of mixed type,
define the appropriate properties in your schema as
:ref:`mixed <react-nativedata-types-mixed>` types. You can then set these
``mixed`` properties as a :ref:`list <react-native-realm-list>` or a
:ref:`dictionary <react-native-data-types-dictionaries>` collection of mixed elements.
Note that ``mixed`` *cannot* represent a set or an embedded object.

.. tip::

   - Use a map of mixed data types when the type is unknown but each value will have a unique identifier.
   - Use a list of mixed data types when the type is unknown but the order of objects is meaningful.


.. _react-native-client-relationships:

Relationships
-------------

You can define relationships between objects in a realm. Realm models
relationships as object properties that point to other objects of a
given type in the realm. You define a relationship at the type level by
declaring a property in the type's schema where the value is another
object type.

Querying a relationship is just as performant as a regular property.
Relationships are direct references to other objects, so you don't need
to use joins and complex models to define and use them like you would in
a relational database. Instead, you can access related objects by
reading and writing to the relationship property directly.

There are three primary types of relationships between objects:

- :ref:`One-to-One Relationship <react-native-to-one-relationship>`
- :ref:`One-to-Many Relationship <react-native-to-many-relationship>`
- :ref:`Inverse Relationship <react-native-inverse-relationship>`

.. note:: Realm vs Other Databases

   Objects often contain direct references to other objects.
   When working with objects and references,
   you typically copy data from database storage into application memory.
   This situation leaves the developer with a choice of what to copy
   into memory:

   - You can copy all referenced objects into memory ahead of time.
     This means that all referenced data is always available quickly
     but can use up a lot of resources. If a system has limited memory,
     this may not be viable.

   - You can copy just a foreign key value for each object. Later, you
     can use the key to look up the full object when you need it.
     These "lazy" lookups are more memory-efficient than copying all
     referenced objects ahead of time. However, they require you to
     maintain more query code and use runtime lookups that can slow
     your app down.

   Realm's query architecture avoids the tradeoff between memory usage
   and computational overhead. Instead, Realm queries can directly
   reference :ref:`related objects <react-native-relationships>` and
   their properties on disk.

.. include:: /includes/see-also-define-relationship-in-app-services-ui.rst
