.. _flutter-collections:

=========================
Collections - Flutter SDK
=========================

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

A Realm collection contains zero or more instances of a
:ref:`Realm supported data type <flutter-data-types>`.
In a Realm collection, all objects in a collection are of the same type.

You can filter and sort any collection using Realm Database's
:ref:`query language <flutter-filter-results>`. Collections are
:ref:`live objects <flutter-live-object>`, so they always reflect the
current state of the realm instance.  The contents of a collection update
when new elements are added to or deleted from the collection or from its Realm.

You can also listen for changes in the collection by subscribing
to :ref:`change notifications <flutter-react-to-changes>`.

Realm Database has two kinds of collections: **RealmLists** and **RealmResults**.

.. _flutter-realm-list:

RealmList Collections
---------------------

Realm objects can contain lists of any supported data type.
Realm uses the :flutter-sdk:`RealmList <realm/RealmList-class.html>` data type
to store the data.

When you include ``RealmObjects`` as the items in a ``RealmList``,  it represents a :ref:`to-many
relationship <flutter-many-to-one-relationship>`.

Deleting an object from the database will remove it from any lists
where it existed. Therefore, a list of objects will never contain null objects.
However, lists of primitive types can contain null values. If you do not
want to allow null values in a list, then either use non-nullable types in
the list declaration (for example, use ``List<int>`` instead of
``List<int?>``).

Lists are mutable and you can add and remove elements on a list within a write transaction.

Add a RealmList to a Schema
~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can add a ``RealmList`` to your Realm Object schema by defining a property as type
``List<T>`` where ``T`` can be any :ref:`supported Realm data type <flutter-data-types>`
(except other collections), in your Realm Object model.

.. literalinclude:: /examples/generated/flutter/data_types_test.snippet.realmlist-model.dart
   :language: dart

Query a RealmList
~~~~~~~~~~~~~~~~~

.. literalinclude:: /examples/generated/flutter/data_types_test.snippet.realmlist-use.dart
   :language: dart

RealmResults Collections
------------------------

A :flutter-sdk:`RealmResults <realm/RealmResults-class.html>`
collection represents the lazily-evaluated
results of a query operation. Unlike a ``RealmList``, results are immutable: you
cannot add or remove elements on the results collection.
This is because the contents of a results collection are determined by a
query against the database.

:flutter-sdk:`Realm.all() <realm/Realm/all.html>` and :flutter-sdk:`Realm.query()
<realm/Realm/query.html>` return ``RealmResults``.
For more information on querying Realm Database, refer to :ref:`Read Operations <flutter-read-data>`.

.. literalinclude:: /examples/generated/flutter/data_types_test.snippet.realmresults-use.dart
   :language: dart

.. _flutter-lazy-evaluated-results:

Results are Lazily Evaluated
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Realm Database only runs a query when you actually request the
results of that query, e.g. by accessing elements of the
results collection. This lazy evaluation enables you to
write elegant, highly performant code for handling large
data sets and complex queries.

Work with Collections
---------------------

.. _flutter-live-collections:

Collections are Live
~~~~~~~~~~~~~~~~~~~~

Like :ref:`live objects <flutter-live-object>`, Realm collections
are *usually* live:

- Live **results collections** always reflect the current results of the associated query.
- Live **lists** of ``RealmObjects`` always reflect the current state of the relationship on the realm instance.

There are two cases, however, when a collection is **not** live:

- The collection is unmanaged: a ``RealmList`` property of a Realm object
  that has not been added to a realm yet or that has been copied from a
  realm.
- The collection is :ref:`frozen <flutter-freeze>`.

Combined with :ref:`listening for changes on a collection <flutter-react-to-changes>`,
live collections enable clean, reactive code.
For example, suppose your view displays the results of a query.
You can keep a reference to the results collection in your view class,
then read the results collection as needed without having to refresh it or
validate that it is up-to-date.

.. important:: Indexes may change

   Since results update themselves automatically, do not
   store the positional index of an object in the collection
   or the count of objects in a collection. The stored index
   or count value could be outdated by the time you use
   it.
