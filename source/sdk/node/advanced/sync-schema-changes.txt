.. _node-sync-schema-changes:

==============================================
Schema Changes for Synced Realms - Node.js SDK
==============================================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------
When developing an application using {+sync+}, you may want to make changes to
your schema at some point. {+client-database+} offers an intuitive API for
making schema changes to synced {+realms+} that is backwards compatible allowing
old clients continue to sync with newer ones.

.. note::

   This page details how to modify a schema when working with {+sync+}, if you
   are developing your application without {+sync+} refer to the :doc:`Modify an
   Object Schema </sdk/node/examples/modify-an-object-schema>` page.


Additive Changes
----------------
Additive changes, such as adding a class or adding a field to a class, are
applied automatically to synced {+realms+}, meaning you can alter the schema
with no additional configuration.

Add a Property
~~~~~~~~~~~~~~
Unlike {+realms+} that are not-synchronized to a server, synced realms do not require you to specify a schema version.

.. example::

   In the following example, an application is developed with an initial ``Dog`` schema: 

   .. literalinclude:: /examples/generated/node/sync-schema-changes.codeblock.sync-schema-changes-add-a-property-initial-schema.js
      :language: javascript

   The developer adds an ``owner`` property to the ``Dog`` schema, that depicts a
   relationship to a ``Person`` class:

   .. literalinclude:: /examples/generated/node/sync-schema-changes.codeblock.sync-schema-changes-add-a-property-updated-schema.js
      :language: javascript


Delete a Property
~~~~~~~~~~~~~~~~~
To maintain backwards compatiblility, removing a field from a schema doesn’t
delete the field from the database, but instead instructs Realm to ignore that
field. New objects retain the removed field, but Realm automatically sets the
field's value set to null. Realm sets fields that are non-nullable to an
appropriate empty value, such as a 0 for integer values, and empty string for
string values.

.. example::

   In the following example, an application developer opens a realm with an initial ``Dog``
   schema, and create a dog named 'Scruffy'.

   .. literalinclude:: /examples/generated/node/sync-schema-changes.codeblock.sync-schema-changes-delete-a-property-initial-schema.js
      :language: javascript


   The developer then decides to remove the ``breed`` property from the ``Dog``
   schema, and insert a dog named 'Spot'. 

   .. literalinclude:: /examples/generated/node/sync-schema-changes.codeblock.sync-schema-changes-delete-a-property-updated-schema.js
      :language: javascript

   Finally, he prints both dog objects to see their values:

   .. literalinclude:: /examples/generated/node/sync-schema-changes.codeblock.sync-schema-changes-delete-a-property-log-objects.js
      :language: javascript


   The console prints the following output:

   .. code-block:: shell

      Scruffy the dog: {
         name: 'Scruffy',
         breed: 'Husky'
      }
      Spot the dog: {
         name: 'Spot',
         breed: ''
      }

Destructive Changes
-------------------
Destructive changes to a schema are usually modifications of existing fields, such as:

- Changing a property’s type but keeping the same name
- Changing a primary key
- Changing a property from optional to required (or vice-versa)

Synchronized {+realms+} only support additive changes to a schema. Attempting to
perform a destructive change on a synchronized {+realm+} will lead to errors
like the following:

.. code-block:: shell

   {
    message: 'The following changes cannot be made in additive-only schema mode:\n' +
      "- Property 'Task.difficulty' has been made optional.",
    errorCode: 1
   }

Using Partner Collections to Modify Properties of a Schema
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you are developing an application using {+sync+}, you can create a second
version of your collection, with a schema that has the modifications to the
fields that you require. Doing so requires you to always have data in both
collections synchronized. Copy the {+service-short+} objects from the first
collection to the second collection to get it up-to-date. To keep the
collections synchronized when data is subsequently changed, create a
:ref:`database trigger <create-a-database-trigger>` for each respective
collection to copy the changed data from the collection to its partner
collection.

.. example::

   In the following example, an application developer opens a synced {+realm+}
   with an initial ``Task`` schema with an ``_id``, ``name``, and ``difficulty``
   field. The developer then creates some sample tasks.

   .. literalinclude:: /examples/generated/node/sync-schema-changes.codeblock.sync-schema-changes-destructive-changes-initial-collection.js
      :language: javascript


   The developer then decides to change the ``difficulty`` field of the ``Task``
   collection to optional, he does this by creating a second collection as a
   partner collection of the first and copying the objects in the first
   collection to the second collection.

   .. code-block:: javascript
      :caption: Create a Copy of the Initial Collection and Modify a Property
 
   .. literalinclude:: /examples/generated/node/sync-schema-changes.codeblock.sync-schema-changes-destructive-changes-second-version-collection.js
      :language: javascript

   To copy any new changes to the initial ``Task`` collection into the
   ``TaskV2`` collection, the developer  creates a :ref:`database trigger
   <create-a-database-trigger>`. The trigger fires whenever {+atlas+} performs a
   insert, update, delete or replace operation on the ``Task`` collection.
 
   .. literalinclude:: /examples/Triggers/copy-data-from-initial-collection.js
      :language: javascript
      :caption: copyDataFromTasksToTasksV2 trigger
      :emphasize-lines: 6, 7

   To copy any new changes to the ``TaskV2`` collection into the
   ``Task`` collection, the developer  creates a :ref:`database trigger
   <create-a-database-trigger>`. The trigger fires whenever {+atlas+} performs a
   insert, update, delete or replace operation on the ``TaskV2`` collection.

   .. literalinclude:: /examples/Triggers/copy-data-from-second-version-collection.js
      :language: javascript
      :caption: copyDataFromTasksV2ToTasks trigger
      :emphasize-lines: 6, 7

Summary
-------
- Schema changes on synced {+realms+} are backwards compatible, allowing old clients continue to sync with newer ones.
- Additive changes to the schema of a synced {+realm+} do not require any additional configuration. 
- Synchronized {+realms+} only support additive changes to a schema.
- Destructive changes are modifications to existing fields of a schema.
- Synchronized {+realms+} do not support destructive changes directly.
- To perform destructive changes, create a partner collection that has the modifications to the fields of the schema that you require, and manually copy the data from the first collection to the second collection.
- To keep partner collections synchronized, set up database triggers to copy changed data from one collection to its partner.