.. _dotnet-realm-database-reads:

====================
Reads and Writes
====================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

.. _dotnet-read-from-realm:

Read from Realm Database
------------------------

A read from a :term:`{+realm+}` generally consists of the following
steps:

- Get all :ref:`objects <dotnet-objects>` of a certain type from the {+realm+}.
- Optionally, :ref:`filter <dotnet-filter-results>` the results using the :ref:`query engine <dotnet-client-query-engine>`.
- Optionally, :ref:`sort <dotnet-sort-results>` the results.

.. note:: About the examples on this page

   The examples on this page use the data model of a project
   management app that has two {+service-short+} object types: ``Project``
   and ``Task``. A ``Project`` has zero or more ``Tasks``.

   See the schema for these two classes, ``Project`` and
   ``Task``, below:

   .. literalinclude:: /examples/Schemas/ProjectAndTask.cs
      :language: csharp


.. _dotnet-get-all-objects:

Get All Objects
~~~~~~~~~~~~~~~

The first step of any read is to **get all objects** of a
certain type in a {+realm+}. With this results collection, you
can operate on all instances on a type or filter and sort to
refine the results.

.. example::

   In order to access all instances of ``Project`` and ``Task``, use
   the following syntax:

   .. literalinclude:: /examples/CRUD/Objects.cs
      :language: csharp


.. _dotnet-filter-results:

Filter Results
~~~~~~~~~~~~~~

A **filter** selects a subset of results based on the
value(s) of one or more object properties. {+client-database+} provides a
full-featured :ref:`query engine <dotnet-client-query-engine>` you
can use to define filters. The most common use case is to
find objects where a certain property matches a certain
value. Additionally, you can compare strings, aggregate over
collections of numbers, and use logical operators to build
up complex queries.

.. example::

   In the following example, we use the query
   engine's comparison operators to:

   - Find high priority tasks by comparing the value of the ``priority`` property value with a threshold number, above which priority can be considered high.
   - Find just-started or short-running tasks by seeing if the ``progressMinutes`` property falls within a certain range.
   - Find unassigned tasks by finding tasks where the ``assignee`` property is equal to null.
   - Find tasks assigned to specific teammates Ali or Jamie by seeing if the ``assignee`` property is in a list of names.

   .. literalinclude:: /examples/Query/Comparison.cs
      :language: csharp


.. _dotnet-sort-results:

Sort Results
~~~~~~~~~~~~

A **sort** operation allows you to configure the order in
which {+client-database+} returns queried objects. You can sort based on
one or more properties of the objects in the results
collection.

{+client-database+} only guarantees a consistent order of results when the
results are sorted.

.. example::

   The following code sorts the projects by name in reverse
   alphabetical order (i.e. "descending" order).

   .. literalinclude:: /examples/CRUD/Sort.cs
      :language: csharp


.. _dotnet-find-by-primary-key:

Find by Primary Key
~~~~~~~~~~~~~~~~~~~
You can also find a specific item by its primary key using the 
:dotnet-sdk:`Find <reference/Realms.Realm.html#Realms_Realm_Find__1_System_Nullable_System_Int64__>`
method, as shown in the following example: 

.. literalinclude:: /examples/Query/FindByPrimaryKey.cs
   :language: csharp


Write to a Realm Database
--------------------------

When writing (creating and updating) documents, all writes must happen in a 
transaction.

.. example::

   The following code shows how to run a transaction with
   the {+realm+}'s write method. If the code in the callback
   throws an exception, {+client-database+} cancels the transaction.
   Otherwise, {+client-database+} commits the transaction.

   .. literalinclude:: /examples/CRUD/BatchUpdate.cs
      :language: csharp


.. _dotnet-create-an-object:

Create an Object
----------------

.. example::

   This code demonstrates how to create an object with {+client-database+}:

   .. literalinclude:: /examples/CRUD/Create.cs
      :language: csharp


.. _dotnet-upsert:

Upsert an Object
~~~~~~~~~~~~~~~~

.. example::

   This code demonstrates how to upsert an object with
   {+realm+}. We create a new user named "Drew" and then update
   their name to "Andy" via upsert:

   .. literalinclude:: /examples/CRUD/Upsert.cs
      :language: csharp


.. _dotnet-update:

Update an Object
----------------

.. example::

   This code changes the dog's name to "Wolfie" and
   increments the age by 1:

   .. literalinclude:: /examples/CRUD/Update.cs
      :language: csharp


.. _dotnet-batch-update:

Update a Collection
~~~~~~~~~~~~~~~~~~~

.. example::

   The following code demonstrates how to update a
   collection. Thanks to the :ref:`implicit inverse
   relationship <dotnet-inverse-relationship>` between the
   Dog's ``owner`` property and the Person's ``dogs``
   property, {+client-database+} automatically updates Ali's
   list of dogs.

   .. literalinclude:: /examples/CRUD/BatchUpdate.cs
      :language: csharp


.. _dotnet-delete:

Delete an Object
----------------

.. example::

   The following code shows how to delete one object from
   its {+realm+}:

   .. literalinclude:: /examples/CRUD/Delete.cs
      :language: csharp


.. _dotnet-delete-collection:

Delete a Collection
~~~~~~~~~~~~~~~~~~~

.. example::

   The following code demonstrates how to delete a
   collection from a {+realm+}:

   .. literalinclude:: /examples/CRUD/DeleteCollection.cs
      :language: csharp

.. _dotnet-cascading-delete:

Cascading Delete
~~~~~~~~~~~~~~~~

Sometimes, you have :ref:`dependent objects
<dotnet-client-relationships>` that you want to delete when
you delete the parent object. We call this a **cascading
delete**. {+client-database+} will not delete the dependent objects for
you. If you do not delete the objects yourself, they will
remain orphaned in your {+realm+}. Whether or not this is a
problem depends on your application's needs.

Currently, the best way to delete dependent objects is to
iterate through the dependencies and delete them before
deleting the parent object.

.. example::

   The following code demonstrates how to perform a
   cascading delete by first deleting all of Ali's dogs,
   then deleting Ali:

   .. literalinclude:: /examples/CRUD/CascadingDelete.cs
      :language: csharp


.. _dotnet-delete-all-of-object:

Delete All Instances of a Type
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

{+client-database+} supports deleting all instances of a
:ref:`{+service-short+} type <dotnet-objects>` from a
{+realm+}.

.. example::

   The following code demonstrates how to delete all
   Dog instances from a {+realm+}:

   .. literalinclude:: /examples/CRUD/DeleteAllOfClass.cs
      :language: csharp


.. _dotnet-delete-all:

Delete Everything
~~~~~~~~~~~~~~~~~

It is possible to delete all objects from the {+realm+}. This
does not affect the schema of the {+realm+}. This is useful for
quickly clearing out your {+realm+} while prototyping.

.. example::

   The following code demonstrates how to delete everything
   from a {+realm+}:

   .. literalinclude:: /examples/CRUD/DeleteAll.cs
      :language: csharp
