======
Writes
======

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------

Realm supports many concurrent readers, but there can be
only one writer at a time. All writes must happen in a
**transaction**.

A **transaction** is a list of read and write operations
that a database treats as a single indivisable operation. In
other words, a transaction is *all or nothing*: either all
of the operations in the transaction succeed or none of the
operations in the transaction take effect.

At the end of a write operation, you can either **commit** a
transaction or **cancel** it:

- When you **commit** a transaction, Realm writes all changes to
  disk. If the realm is synced, Realm queues the change for
  synchronization with the Realm Object Server.
- When you **cancel** a write transaction, all changes are
  discarded (or "rolled back").

.. _acid-compliance:

Realm is ACID Compliant
~~~~~~~~~~~~~~~~~~~~~~~

Rightfully, you expect strict guarantees about how your
database handles your data. Realm is :wikipedia:`ACID
compliant <ACID>`:

- The all or nothing nature of transactions establishes Realm's :wikipedia:`atomicity <Atomicity_(database_systems)>`.
- The validation of changes against the schema avoids data corruption and establishes Realm's :wikipedia:`consistency <Consistency_(database_systems)>`.
- The allowance of only one writer at a time ensures thread safety and establishes Realm's :wikipedia:`isolation <Isolation_(database_systems)>`.
- Writing to disk upon transaction commit establishes Realm's :wikipedia:`durability <Durability_(database_systems)>`. 

.. _open-a-transaction:

Run a Transaction
-----------------

Run a transaction by passing a callback the realm's write
method. If the code in the callback throws an exception,
Realm cancels the transaction. Otherwise, Realm commits the
transaction immediately after the code block.

.. admonition:: Concurrency Concerns
   :class: important

   Since transactions block each other, it is best to avoid
   opening transactions on both the UI thread and a
   background thread. If you are using Sync, avoid opening
   transactions on the UI thread altogether.

.. example::

   The following code shows how to run a transaction with
   the realm's write method. If the code in the callback
   throws an exception, Realm cancels the transaction.
   Otherwise, Realm commits the transaction.

   .. include:: /examples/CRUD/Transaction.rst

   You can manually **open**, **commit**, and **cancel** a
   transaction, but we recommend avoiding this wherever
   possible. You must commit or cancel all transactions that
   you open. Transactions block each other, so if you
   accidentally leave a transaction open indefinitely, your
   app will not behave properly.

   .. include:: /examples/CRUD/TransactionCounterexample.rst

.. _create-an-object:

Create an Object
----------------

In general, instantiate :doc:`Realm objects
</data-model/objects>` as you would any other object. Add
the object to the realm in a transaction. When you add an
instance to the realm, it becomes **managed** by that realm.

With the Java and JavaScript SDKs, instead use the realm's
factory method in a transaction to instantiate your class.
This automatically inserts the instance into the realm.

.. example::

   This code demonstrates how to create an object with Realm:

   .. include:: /examples/CRUD/Create.rst

.. _update:

Update
------

Within a transaction, you can update a Realm object the same
way you would update any other object in your language of
choice: just assign a new value to the property or update
the property.

.. example::

   This code changes the dog's name to "Wolfie" and
   increments the age by 1:

   .. include:: /examples/CRUD/Update.rst

.. _upsert:

Upsert
~~~~~~

Sometimes, you don't know if an object exists in the realm
or not. If it exists, you want to update it; if it does not
exist, you want to create it. We call this an **upsert**
because it is an "**update** or **insert**" operation. For
example, consider the task of importing a dataset to an
existing realm. Upserting is an elegant way to update
existing entries while adding any new entries.

If your object uses a primary key, you can upsert by
passing a special parameter to realm's add method.

.. example::

   This code demonstrates how to upsert an object with
   Realm. We create a new user named "Drew" and then update
   their name to "Andy" via upsert:

   .. include:: /examples/CRUD/Upsert.rst

.. _batch-update:

Batch Update
~~~~~~~~~~~~

Realm supports **batch updates** of fields on a collection.
A batch update applies the same update to several objects at
once.

.. example::

   The following code demonstrates how to batch update a
   collection. Thanks to the :ref:`implicit inverse
   relationship <inverse-relationship>` between the Dog's
   ``owner`` field and the Person's ``dogs`` field, Realm
   automatically updates the corresponding field, even when
   executing a batch update.

   .. include:: /examples/CRUD/BatchUpdate.rst

.. _delete:

Delete
------

In general, to delete an object from a realm, pass the
instance to the delete method of the realm within a
transaction.

With the Java SDK, call ``deleteFromRealm()`` on the
instance itself.

.. admonition:: Discard references after delete
   :class: note

   When you delete an object from the realm, it's a good
   idea to discard your reference to that object. For
   example, set the variable to null.

.. example::

   The following code shows how to delete one object from
   its realm:

   .. include:: /examples/CRUD/Delete.rst

.. _delete-collection:

Delete a Collection
~~~~~~~~~~~~~~~~~~~

In general, to delete a collection of objects from a realm,
pass the collection to the delete method of the realm within
a transaction.

With the Java SDK, call ``deleteFromRealm()`` on the
collection itself.

.. example::

   The following code demonstrates how to delete a
   collection from a realm:

   .. include:: /examples/CRUD/DeleteCollection.rst

.. _cascading-delete:

Cascading Delete
~~~~~~~~~~~~~~~~

Sometimes, you have :doc:`related objects
</data-model/relationships>` that you want to delete when
you delete the parent object. We call this a **cascading
delete**. If you do not delete the dependent objects, they
will remain orphaned in your realm. Whether or not this is a
problem depends on your application's needs.

Currently, the best way to delete dependent objects is to
iterate through the dependencies and delete them before
deleting the parent object.

.. example::

   The following code demonstrates how to perform a
   cascading delete by first deleting all of Ali's dogs,
   then deleting Ali:

   .. include:: /examples/CRUD/CascadingDelete.rst

.. _delete-all-of-object:

Delete All Instances of a Type
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Realm supports deleting all instances of a :doc:`Realm type
</data-model/objects>` from a realm.

.. example::

   The following code demonstrates how to delete all
   Dog instances from a realm:

   .. include:: /examples/CRUD/DeleteAllOfClass.rst

.. _delete-all:

Delete Everything
~~~~~~~~~~~~~~~~~

It is possible to delete all objects from the realm. This is
useful for quickly clearing out your realm while
prototyping.

.. example::

   The following code demonstrates how to delete everything
   from a realm:

   .. include:: /examples/CRUD/DeleteAll.rst

