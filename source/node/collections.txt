.. _node-client-collections:

===========
Collections
===========

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------

One of the fundamental building blocks when working with any database is the
**collection**. A collection is a built-in object that contains zero or more
instances of one :ref:`{+service-short+} type <node-realm-objects>`.
{+service-short+} collections are homogenous, i.e. all objects in a collection
are of the same type.

You can filter and sort any collection using {+client-database+}'s
:ref:`query engine <node-client-query-engine>`. Collections are
:ref:`live <node-live-object>`, so they always reflect the
current state of the :term:`{+realm+} instance` on the current
thread. You can also listen for changes in the collection by subscribing
to :ref:`collection notifications <node-collection-notifications>`.

.. _node-results-collections:

Results Collections
~~~~~~~~~~~~~~~~~~~

A **results collection** represents the lazily-evaluated results of a query
operation. Results are immutable: you cannot add or remove elements on the
results collection. Results have an associated query that determines their
contents.



.. _node-list-vs-results:

List vs. Results
----------------

When you need a collection, you can use the following rule
of thumb to determine whether a list or a results collection
is appropriate:

- When you define the properties of your {+service-short+} objects, use lists to define :ref:`to-many relationships <node-to-many-relationship>` except :ref:`implicit inverse relationships <node-inverse-relationship>`.
- Use results everywhere else.

To understand these different use cases, consider whether
you should be able to add or remove objects directly. Lists
allow you to add and remove objects directly, because you
control the relationships. Results collections do not allow
you to add or remove objects directly, because their contents
are determined by a query.

.. example::

   Consider a {+service-short+} type called Person with a field called
   ``emails`` that is a collection of strings representing
   email addresses. You control this data. Your application
   needs to add and remove email addresses from your Person
   instances. Therefore, use a **list** to define the field
   type of ``emails``.

   On the other hand, when you query the {+realm+} for all
   Persons over the age of 25, it would not make sense for
   you to add or remove Persons directly to the resulting
   collection. The contents of that collection only change
   when the query matches a different set of Persons.
   Therefore, {+client-database+} gives you a **results** collection.

.. _node-collection-type-for-implicit-inverse-relationships:

.. note:: Inverse one-to-many relationship property exception

   Since {+client-database+} automatically determines the contents of
   :ref:`implicit inverse relationship
   <node-inverse-relationship>` collections, you may not add
   or remove objects from such a collection directly.
   Therefore, the type of such a one-to-many relationship
   property is actually a results collection, not a list.

Summary
-------

- A {+service-short+} **collection** is a homogenous container of zero
  or more instances of one
  :ref:`{+service-short+} type <node-realm-objects>`.

- Collections are :ref:`live <node-live-object>`, i.e. auto-updating, unless
  they are a snapshot or they are not part of a {+realm+}.

- Lazy evaluation of results collections means there is no need to
  design a special query to get limited or paginated results. Perform
  the query and read from the results collection as needed.

- There are two main kinds of collection: **lists** and **results**.
  Lists define the :ref:`to-many relationships <node-to-many-relationship>`
  of your {+service-short+} types, while results represent the
  lazily-loaded output of a :ref:`read operation <node-realm-database-reads>`.
