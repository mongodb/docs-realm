.. _node-realm-database-reads:

=====
Reads
=====

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------



.. _node-read-from-realm:

Read from Realm Database
------------------------

A read from a :term:`{+realm+}` generally consists of the following
steps:

- Get all :ref:`objects <node-realm-objects>` of a certain type from the {+realm+}.
- Optionally, :ref:`filter <node-filter-results>` the results using the :ref:`query engine <node-client-query-engine>`.
- Optionally, :ref:`sort <node-sort-results>` the results.

All query, filter, and sort operations return a
:ref:`results collection <node-results-collections>`. The results
collections are live, meaning they always contain the latest
results of the associated query.


.. note::

   Open a realm to use the examples on this page. To learn how to open a
   realm, read the :ref:`Quick Start
   <node-quick-start-open-realm>` doc.

.. note:: About the examples on this page

   The examples on this page use the data model of a project
   management app that has two {+service-short+} object types: ``Project``
   and ``Task``. A ``Project`` has zero or more ``Tasks``.

   See the schema for these two classes, ``Project`` and
   ``Task``, below:

   .. tabs-realm-languages::

      .. tab::
          :tabid: javascript

          .. literalinclude:: /examples/Schemas/ProjectAndTask.js
            :language: javascript


.. _node-get-all-objects:

Get All Objects
~~~~~~~~~~~~~~~

The first step of any read is to **get all objects** of a
certain type in a {+realm+}. With this results collection, you
can operate on all instances on a type or filter and sort to
refine the results.

.. example::

   In order to access all instances of ``Project`` and ``Task``, use
   the following syntax:

   .. tabs-realm-languages::

      .. tab::
          :tabid: javascript

          .. literalinclude:: /examples/CRUD/Objects.js
            :language: javascript


.. _node-filter-results:

Filter Results
~~~~~~~~~~~~~~

A **filter** selects a subset of results based on the
value(s) of one or more object properties. {+client-database+} provides a
full-featured :ref:`query engine <node-client-query-engine>` you
can use to define filters. The most common use case is to
find objects where a certain property matches a certain
value. Additionally, you can compare strings, aggregate over
collections of numbers, and use logical operators to build
up complex queries.

.. example::

   In the following example, we use the query
   engine's comparison operators to:

   - Find high priority tasks by comparing the value of the ``priority`` property value with a threshold number, above which priority can be considered high.
   - Find just-started or short-running tasks by seeing if the ``progressMinutes`` property falls within a certain range.
   - Find unassigned tasks by finding tasks where the ``assignee`` property is equal to null.
   - Find tasks assigned to specific teammates Ali or Jamie by seeing if the ``assignee`` property is in a list of names.

   .. tabs-realm-languages::

      .. tab::
          :tabid: javascript

          .. literalinclude:: /examples/Query/Comparison.js
            :language: javascript


.. _node-sort-results:

Sort Results
~~~~~~~~~~~~

A **sort** operation allows you to configure the order in
which {+client-database+} returns queried objects. You can sort based on
one or more properties of the objects in the results
collection.

{+client-database+} only guarantees a consistent order of results when the
results are sorted.

.. example::

   The following code sorts the projects by name in reverse
   alphabetical order (i.e. "descending" order).

   .. tabs-realm-languages::

      .. tab::
          :tabid: javascript

          .. literalinclude:: /examples/CRUD/Sort.js
            :language: javascript



.. _node-realm-read-characteristics:




Summary
-------

- To read from {+client-database+}, first get all objects of a certain type from the {+realm+}, then filter using the query engine, then (optionally) sort the results.
- When you read, the results are not copies. Instead, through memory mapping, results point directly to the version on disk.
- Queries are lazily-evaluated.
