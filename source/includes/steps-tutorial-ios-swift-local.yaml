---
title: Clone the Client App Repository
ref: clone-the-client-app-repository
content: |
  We've already put together a task tracker iOS application that has most of the
  code you'll need. You can clone the client application repository directly
  from :github:`GitHub <mongodb-university/realm-tutorial-ios-swift>`:

  .. code-block:: shell

     git clone --branch start https://github.com/mongodb-university/realm-tutorial-ios-swift.git

  .. tip::
   
     The ``start`` branch is an incomplete version of the app that we will
     complete in this tutorial. To view a local-only version of the app:

     1. Check out the ``local`` branch.
     2. Install CocoaPod dependencies.
     3. Run the app.

  In your terminal, run the following commands to navigate to the task tracker
  client application and install its dependencies with `CocoaPods
  <https://guides.cocoapods.org/using/getting-started.html>`__:

  .. important::

     CocoaPods minimum version 1.10 is required to install Realm.

  .. code-block:: shell
     
     cd realm-tutorial-ios-swift
     pod install --repo-update

  Once the installation is complete, use Xcode to open the xcworkspace generated
  by CocoaPods, which has all of the dependencies configured. You can do this
  from the command line:

  .. code-block:: shell

     open "Task Tracker.xcworkspace"

---
title: Explore the App Structure
ref: explore-the-app-structure
content: |

  In the Xcode Project Navigator, you can see the source files of the task
  tracker application in the ``Task Tracker`` folder. The relevant files are as follows:

  .. cssclass:: config-table
  .. list-table::
     :header-rows: 1
     :widths: 40 60
     
     * - File
       - Purpose

     * - Models.swift
       - Defines the Realm object models used by this app.

     * - SceneDelegate.swift
       - Declares the global Realm app instance used by other parts of the app.
     
     * - WelcomeViewController.swift
       - Implements the login and user registration functionality.
      
     * - ProjectsViewController.swift
       - The list of projects that the logged-in user is a member of.
     
     * - TasksViewController.swift
       - The list of tasks for a given project.

     * - ManageTeamViewController.swift
       - This file isn't used in the part 1 of the tutorial,
         but is used to manage members of a user's project in part 2.

---
title: Define the Object Models
ref: define-the-object-models
content: |
  Navigate to the Models.swift file to implement the Realm Object Models used in
  this app. Notice that the Realm object models derive from ``Object``
  from the ``RealmSwift`` library, which allows us to store them in
  {+client-database+}:

  .. note::

      To learn more about how {+service-short+} Object models are used in iOS applications, 
      see :ref:`ios-read-and-write-data` in our iOS client guide. 

  Turn the Task class into a Realm object model:

  .. literalinclude:: /tutorial/generated/swift-ios/local/Models.codeblock.task-model.swift
     :language: swift

---
title: Implement the Projects List
ref: implement-the-projects-list
content: |
  Open the ProjectsViewController.swift file, which is where we present the user
  with a list of projects they are a member of. The WelcomeViewController passes
  a username to this view, so we can generate a project {+realm+} for the user.

  Let's provide a way for a user to log out and get back to the
  WelcomeViewController. The ``viewDidLoad()`` method hooks up the Log Out
  button at the top of the view to the ``logOutButtonDidClick()`` method. We can
  implement ``logOutButtonDidClick()`` as follows:

  .. literalinclude:: /tutorial/generated/swift-ios/local/ProjectsViewController.codeblock.log-out-button-did-click.swift
     :language: swift

  Since the ProjectsViewController implements the UITableViewDelegate protocol
  for its own list, let's implement these methods. First, implement the
  ``tableView(_:numberOfRowsInSection:)`` method to return the number of
  available projects to the current user. Since the user always has access to
  their own project, we always return 1:

  .. literalinclude:: /tutorial/generated/swift-ios/local/ProjectsViewController.codeblock.number-of-rows-in-section.swift
     :language: swift

  Next, implement the ``tableView(_:cellForRowAt:)`` to fill out the project
  information for each cell:

  .. literalinclude:: /tutorial/generated/swift-ios/local/ProjectsViewController.codeblock.cell-for-row-at.swift
     :language: swift

  Finally, implement the ``tableView(_:didSelectRowAt:)`` method to handle what
  happens when the user clicks a project in the list. We'll open the
  project {+realm+} before navigating to the TasksViewController so that
  if anything goes wrong, we can handle the error before launching a
  separate view:

  .. literalinclude:: /tutorial/generated/swift-ios/local/ProjectsViewController.codeblock.did-select-row-at.swift
     :language: swift

---
title: Implement the Tasks List
ref: implement-the-tasks-list
content: |
  Navigate to the TasksViewController.swift file, where we'll implement the list
  of Tasks in a Project. The TasksViewController class holds an array of Task
  objects. We already converted the Task class to a Realm object model. In order
  to hold a live collection of Realm objects contained in a realm, we need to
  use ``RealmResults`` instead of a standard Swift array. Let's convert that
  property now:

  .. literalinclude:: /tutorial/generated/swift-ios/local/TasksViewController.codeblock.properties.swift
     :language: swift

  We can initialize the ``tasks`` property with a query on the project realm
  passed in from the ProjectsViewController. Once we have the live tasks
  collection, we can observe that for changes:

  .. literalinclude:: /tutorial/generated/swift-ios/local/TasksViewController.codeblock.init.swift
     :language: swift

  Calls to ``observe`` Realm objects return a notificationToken. Always retain
  the notificationToken as long as you want the observation to complete. When
  done observing -- for example, because the user navigated away from this view
  -- be sure to invalidate the token. The ``deinit`` method is a good place to
  do this:

  .. literalinclude:: /tutorial/generated/swift-ios/local/TasksViewController.codeblock.deinit.swift
     :language: swift

  The TasksViewController already populates the UI using the Tasks in the list.
  Check out the ``tableView(_:numberOfRowsInSection:)`` and
  ``tableView(_:cellForRowAt:)`` methods to see how the Realm object model
  version of the Task class and the RealmResults object are drop-in replacements
  for the regular class and array respectively. No changes are required in these
  methods.

  The TasksViewController also wires up the Add button at the top of the view to
  the ``addButtonDidClick()`` method. We can implement the Task creation in this
  method:

  .. literalinclude:: /tutorial/generated/swift-ios/local/TasksViewController.codeblock.add-button-did-click.swift
     :language: swift

  When the user selects a Task in the list, we present them with an action sheet
  to allow them to update the Task's status. Complete the
  ``tableView(_:didSelectRowAt:)`` method implementation as follows:

  .. literalinclude:: /tutorial/generated/swift-ios/local/TasksViewController.codeblock.populate-action-sheet.swift
     :language: swift

  To handle swipes to delete a Task, we implement the
  ``tableView(_:commit:forRowAt:)`` method:

  .. literalinclude:: /tutorial/generated/swift-ios/local/TasksViewController.codeblock.delete-task.swift
     :language: swift

---
title: Run and Test
ref: run-and-test
content: |
  Once you have completed the code, you can run the app and check functionality.

  Click the :guilabel:`Run` button in Xcode. If the app builds successfully,
  here are some things you can try in the app:

  - Create a user with username *test*
  - Navigate to "My Project"
  - Add, update, and remove some tasks

  .. tip::
   
     If something isn't working for you, you can check out the ``local`` branch of 
     this repo to compare your code with our finished solution.
