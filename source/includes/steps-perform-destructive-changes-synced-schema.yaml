title: Consider If You Want to Perform a Destructive Change
ref: consider-destructive-change
content: |
  If you need to add or remove a field to a schema, you need to perform an
  :ref:`additive change <additive-changes-synced-schema>`. You can do this by
  changing your schema directly, without any additional configuration. 

  If you want to modify an existing field of a schema, you need to perform a
  :ref:`destructive change <destructive-changes-synced-schema>`. The following
  steps detail how to perform a destructive change.

  In the following example, the initial collection is specified with the
  following JSON Schema for a ``Task`` collection. The schema for the ``Task``
  contains a ``_id`` field of ``int`` type, and a ``name`` field of ``string``
  type.

  .. code-block:: json
     :caption: Task Schema
     :emphasize-lines: 10

     {
       "title": "Task",
       "bsonType": "object",
       "required": [
         "_id",
         "name"
       ],
       "properties": {
         "_id": {
           "bsonType": "int"
         },
         "_partition": {
           "bsonType": "string"
         },
         "name": {
           "bsonType": "string"
         }
       }
     }
---
title: Set Up a Partner Collection
ref: set-up-a-partner-collection
content: |
  Since destructive changes cannot be performed directly on a synced object
  schema, you can create a partner collection with a schema containing the
  required changes. The partner collections should always have the same data to
  ensure that newer clients can synchronize with older clients.

  To copy the data from your initial collection to your partner collection,
  perform an aggregation by using the :manual:`db.collection.aggregate()
  <reference/method/db.collection.aggregate>` method with the :manual:`Mongo
  shell <mongo>`. 
  
  Match all the documents in the initial collection by passing
  an empty filter to the :manual:`$match operator
  <reference/operator/aggregation/match/>`.

  Modify the desired fields of the initial collection by using the
  :manual:`$addFields operator <reference/operator/aggregation/addFields/>`. In
  the following example, the initial data's ``_id`` field is transformed to a
  ``string`` type using the :manual:`$toString operator
  <reference/operator/aggregation/toString/>`.

  Finally, write the transformed data to the partner collection by using the
  :manual:`$out operator <reference/operator/aggregation/out/>` and specifying
  the partner collection name. In this example, we wrote the data to a new
  collection named ``TaskV2``.

  .. code-block:: shell
     :caption: Match All Documents in the Initial Collection and Output Them to the Partner Collection 

     use "<database-name>" // switch the current db to the db that the Task collection is stored in
     collection = db.Task;
     collection.aggregate([
       { $match: {} }, // match all documents in the Task collection
       {
         $addFields: { // transform the data
           _id: { $toString: "$_id" }, // change the _id field of the data to a string type
         },
       },
       { $out: "TaskV2" }, // output the data to a partner collection, TaskV2
     ]);

  The partner collection, ``TaskV2``, has a JSON Schema that looks like the following:

  .. code-block:: json
     :caption: Task Schema
     :emphasize-lines: 10

     {
       "title": "TaskV2",
       "bsonType": "object",
       "required": [
         "_id",
         "name"
       ],
       "properties": {
         "_id": {
           "bsonType": "string"
         },
         "_partition": {
           "bsonType": "string"
         },
         "name": {
           "bsonType": "string"
         }
       }
     }

---
title: Set up Database Triggers for Your Partner Collections
ref: set-up-db-triggers-partner-collections
content: |
  Once your partner collection is set up, you can use it to read existing data.
  However, any new writes to the data of the either collection will not be shown
  on its partner. This will cause the old clients to be out of sync with the
  new clients that are using the new collection with the modified schema. 

  To do this, set up a :ref:`database trigger <create-a-database-trigger>` for
  each respective collection. When data is written to one collection, the
  trigger's function should perform the write to the partner collection.

  Follow the steps in the :ref:`database trigger <create-a-database-trigger>`
  documentation to create a trigger to copy data from the ``Task`` collection to
  the ``TaskV2`` collection. Ensure that you have checkmarked all operation types in
  the :guilabel:`Operation Type` column. 
 
  Repeat these steps and create a second trigger to copy data from the
  ``TaskV2`` collection to the ``Task`` collection.

  .. figure:: /images/trigger-copyTaskObjectToTaskV2.png
     :alt: Create a Database Trigger to Copy Data from Task to TaskV2
     :width: 750px
     :lightbox:
---
title: Copy Data Within Your Trigger's Function
ref: copy-data-trigger-fn
content: |
  To copy any new changes to the initial collection to the partner collection,
  alter the trigger function's code. 
  
  If the :ref:`change event <database-events>` is a delete, meaning the object
  has been deleted from the collection, delete the object from it's partner
  collection by performing a :manual:`db.collection.deleteOne()
  <reference/method/db.collection.deleteOne>` and passing the
  ``changeEvent.documentKey._id``. In the following example, we call
  :mdn:`parseInt() <Web/JavaScript/Reference/Global_Objects/parseInt>` on the
  ``_id`` field since the ``TaskV2`` collection stores the ``_id`` field as an
  integer.

  If the :ref:`change event <database-events>` is a write, perform the same
  write to the partner collection by performing an :manual:`aggregation
  <reference/method/db.collection.aggregate>`. In the aggregation, match the
  object with the ``changeEvent.documentKey._id`` as an integer. 

  Modify the desired fields of the initial collection by using the
  :manual:`$addFields operator <reference/operator/aggregation/addFields/>`. In
  the following example, the initial data's ``_id`` field is transformed to a
  ``string`` type using the :manual:`$toString operator <reference/operator/aggregation/toString/>`.

  Finally, write the transformed data to the partner collection, by using the
  :manual:`$merge operator <reference/operator/aggregation/merge/>` to avoid
  overwriting existing data.  In this example, we wrote the data to the
  ``TaskV2`` collection.

  .. literalinclude:: /examples/Triggers/copy-data-from-initial-collection.js
     :language: javascript
     :caption: copyTaskObjectToTaskV2 trigger

  To copy data from ``TaskV2`` collection to the ``Task`` collection when the
  trigger fires, alter your trigger function's code. This time, transforming the
  ``_id`` from a string to an integer value.

  .. literalinclude:: /examples/Triggers/copy-data-from-second-version-collection.js
     :language: javascript
     :caption: copyTaskV2ObjectToTask trigger
