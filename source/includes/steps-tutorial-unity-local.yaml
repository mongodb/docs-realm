---
title: Download and Import Unity's Platformer Microgame
ref: download-and-import-unity-platform-microgame
content: |
  Unity Hub comes pre-installed with templates, such as the Platformer
  Microgame, to learn to develop games on the Unity editor. In later steps, you
  will import and {+service-short+} functionality to the game. 

  Click the Learn tab on the left side of Unity Hub to view the list of template projects.
  Scroll to the Platformer Microgame and click it.

  .. figure:: /images/unity-scroll-to-platformer-microgame.png
     :width: 750px
     :alt: Unity Scroll to Platformer Microgame

  On the Modal that appears, click the "Download Project" button to download the
  project. When the download is complete, click "Open Project" to open the project in Unity.  

  .. figure:: /images/unity-download-platformer-microgame.png
     :width: 350px
     :alt: The cluster selection dropown menu

  When you open the Platformer Microgame template, Unity prompts you with the
  option to :guilabel:`Load Scene` or :guilabel:`Load Tutorials`. 

  If you are new to developing with Unity, click :guilabel:`Load Tutorials` to
  learn Unity editor basics, interacting with `GameObjects
  <https://docs.unity3d.com/ScriptReference/GameObject.html>`_, and more. Once
  you feel comfortable working with the Unity Editor, you can continue to the
  next step. Alternatively, if you are already comfortable working with the
  Unity editor, click :guilabel:`Load Scene` and continue to the next
  step in this tutorial.

  Once the scene is loaded, click the play button on the top of the
  screen to enter `play mode <https://docs.unity3d.com/Manual/GameView.html>`_
  and play the game. 

  .. figure:: /images/unity-view-game-in-play-mode.png
     :width: 500px
     :alt: View Game in Play Mode

  .. tip:: Playing the Game

     Try the game to get a feel of what your users will experience. Use the arrow keys for player movement, and the spacebar
     to jump. Navigate through a series of platforms and defeat the "red slime" enemies by hopping on them, making them disappear.
     Collect the yellow "tokens" by touching them. Get to the end of the level to win the game. 

  In later steps, you will use {+realm+} to record how many enemies the player
  defeated per playthrough, how many tokens were collected, and a score that is
  calculated based on the statistics for the current playthrough and how quickly you
  completed the playthrough.
---
title: Update Your Project Manifest 
ref: update-project-manifest
content: |
  Unity uses the `project manifest
  <https://docs.unity3d.com/Manual/upm-manifestPrj.html>`_ to determine packages
  to install into your project. You'll need to update your project's manifest
  file to install {+realm+} and the Unity UI ToolKit and UI Builder packages to
  develop user interfaces to interact with and display data stored in {+realm+}.
  

  .. note:: 

     UI ToolKit and UI Builder are `preview packages
     <https://docs.unity3d.com/Manual/pack-preview.html>`_ that are in
     development by the Unity engineering team. While they provide a simple API
     to develop user interfaces for a tutorial, they should not be used in
     production yet.
  
  .. note:: Package Versions

     The code below lists the latest versions of the necessary packages at the
     time of writing this documentation. Check the links below to see if there
     is a later version of any of the listed packages. However, since the Unity
     UI ToolKit and UI Builder packages are preview packages, their APIs might
     change in newer versions.

     - `{+service-short+} .NET Releases <https://github.com/realm/realm-dotnet/releases>`_
     - `com.unity.ui Changelog <https://docs.unity3d.com/Packages/com.unity.ui@1.0/changelog/CHANGELOG.html>`_
     - `com.unity.ui.builder Changelog <https://docs.unity3d.com/Packages/com.unity.ui.builder@1.0/changelog/CHANGELOG.html>`_

  Update your project's ``/Assets/Packages/manifest.json`` file to include the following dependencies and scoped registries:

  .. code-block:: json

     {
       "dependencies": {
         // ... 
         "io.realm.unity": "10.5.0",
         "com.unity.ui": "1.0.0-preview.16",
         "com.unity.ui.builder": "1.0.0-preview.17"
       },
       "scopedRegistries": [
         {
           "name": "NPM",
           "url": "https://registry.npmjs.org/",
           "scopes": [
             "io.realm.unity"
           ]
         }
       ]
     }
---
title: Clone the Realm Tutorial Repository
ref: clone-the-repository
content: |
  Now that {+realm+}, UI Builder, and UI Toolkit are installed, you can begin
  recording data into {+service-short+} and building a user interface that can read and
  interact with that data.

  We've already put together a repository with most of the code you'll need
  to accomplish that. You can clone the {+service-short+} Tutorial repository directly from
  :github:`GitHub <mongodb-university/realm-tutorial-unity>`:


  .. tabs::

    .. tab:: Clone with Git CLI
        :tabid: shell

        Foo

    .. tab:: Download the Realm Tutorial Repository as a ZIP
        :tabid: zip

        Bar


  .. code-block:: shell

     cd <your-unity-microplatformer-game-path>/Assets/Scripts
     git clone --branch start https://github.com/mongodb-university/realm-tutorial-unity.git

  .. tip::
   
     The ``start`` branch is an incomplete version of the {+service-short+} Tutorial repository that you will
     complete in this tutorial. To view a complete local-only (non-sync) version of the scripts:

     1. Navigate to the root directory of the client application repository:

        .. code-block:: shell

           cd realm-tutorial-unity

     #. Check out the ``local`` branch:

        .. code-block:: shell

           git checkout local
---
title: Explore the Realm Tutorial Repository
ref: explore-the-realm-tutorial-repository
content: |

  In your text editor of choice, such as `Visual Studio
  <https://docs.microsoft.com/en-us/visualstudio/>`_,  you can see the script
  files you will need to add to the game. The relevant files are as follows:

  .. cssclass:: config-table
  .. list-table::
     :header-rows: 1
     :widths: 40 60
     
     * - File
       - Purpose

     * - Stylesheet.uss
       - `USS <https://docs.unity3d.com/Manual/UIE-USS.html>`_ file with the
         global styles for your project.

     * - Leaderboard.uxml
       - `UXML <https://docs.unity3d.com/Manual/UIE-UXML.html>`_ file; defines
         the structure of the Leaderboard user interface.
     
     * - LeaderboardManager.cs
       - Query {+service-short+} and display the top stats.

     * - Scorecard.uxml
       - `UXML <https://docs.unity3d.com/Manual/UIE-UXML.html>`_ file; defines
         the structure of the Scorecard user interface.

     * - ScoreCardManager.cs
       - Listen for changes to the current playthrough stats and update the Scorecard UI.

     * - AuthenticationScreen.uxml
       - `UXML <https://docs.unity3d.com/Manual/UIE-UXML.html>`_ file; defines
         the structure of the Authentication Screen user interface.

     * - AuthenticationManager.cs
       - Interacts with the TextField's of AuthenticationScreen.uxml to
         implement user login. In part 2, you'll add user authentication with the
         {+backend+} Email/Password provider.

     * - RealmController.cs
       - Open a {+realm+}, query the {+realm+} for an existing player or create
         a new one and a new stat for the current playthrough, and perform writes
         to the new ``Stat`` object.

     * - PlayerModel.cs
       - Defines the Player :ref:`{+frontend-schema+} <dotnet-object-models-and-schemas>`.

     * - StatModel.cs
       - Defines the playthrough Stat :ref:`{+frontend-schema+} <dotnet-object-models-and-schemas>`.

     * - Constants.cs (Part 2)
       - Part 2: Declare the {+backend-short+} App ID for the {+sync+} portion of the tutorial.

---
title: Explore the Schemas
ref: explore-schemas
content: |
  In the ``realm-tutorial-unity`` project that you have cloned, navigate to the
  ``PlayerModel.cs`` and ``StatModel.cs`` files in a text editor. These C#
  classes define the schemas for the objects we store in our realms. 
  
  Note the following about the schemas:

  - A ``stat`` is a {+realm+} object representing the statistics of a
    playthrough of the game. For instance, in one playthrough of the game, a
    ``player`` may have defeated 10 enemies, collected 15 tokens, and had a
    score of 210. Each ``Stat` has a ``statOwner`` that is a ``Player`` object.

  - A ``player`` is a {+realm+} object representing the user's logged-in
    character. Each player has a collection (IList) of ``stats`` of which they
    own. 

  - A ``player`` has a string property, ``_id``, that defines the Players' unique partition.
---
title: Create UI Game Objects
ref: create-ui-game-objects
content: |
  Navigate to your Unity Editor's `hierarchy window
  <https://docs.unity3d.com/Manual/Hierarchy.html>`_ to create UI game objects
  that will display the authentication screen, game leaderboard, and player's
  scorecard for the current playthrough of the game. 

  Right-click and select UI > Canvas to create a `Canvas
  <https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/UICanvas.html>`_
  GameObject that will contain your UI elements. 

  .. figure:: /images/unity-create-canvas.png
     :width: 350px
     :alt: Create the Canvas Game Object

  Next, as a child of the Canvas game object, create three `UIDocuments
  <https://docs.unity3d.com/2021.2/Documentation/ScriptReference/UIElements.UIDocument.html>`_
  by right-clicking the Canvas object and selecting UI Toolkit > UI Document
  three times. Name these game objects: ``AuthenticationScreen``, ``Leaderboard``, and
  ``Scorecard``, respectively.

  .. figure:: /images/unity-create-ui-documents.png
     :width: 350px
     :alt: Create the UI Documents

  Next, attach the UXML files to the UI game objects. Click the
  ``AuthenticationScreen`` GameObject to open the `inspector window
  <https://docs.unity3d.com/Manual/UsingTheInspector.html>`_. Then select
  "Authentication" in the "Source Asset" field to set the ``AuthenticationScreen`` game object's
  UXML file to ``Authentication.uxml``.

  .. figure:: /images/unity-tutorial-select-authentication-uxml-source-asset.png
     :width: 350px
     :alt: Select Authentication.uxml as source asset

  Repeat this step twice, setting the ``Leaderboard`` game objects's ``Source Asset`` to
  "Leaderboard" and the ``ScoreCard`` game object's ``Source Asset`` to "ScoreCard".

  Finally, click the play button to enter play mode. You should see something like the following:

  .. figure:: /images/unity-tutorial-static-ui.png
     :width: 500px
     :alt: Unity Tutorial Game with Static UI

  Notice that the "Login & Start" button does not work yet. You'll add that
  functionality in a later step.
---
title: Create a RealmController Game Object
ref: create-realm-controller-object
content: |
  To get and set dynamic values for the ``Leaderboard``, ``ScoreCard``, and
  ``AuthenticationScreen`` components, you need a GameObject to interact with
  {+realm+}. 
  
  Create an empty ``Game Object`` by right-clicking the hierarchy window and
  select "Create Empty". Name the object ``"RealmController"``. Next, `attach
  <https://docs.unity3d.com/Manual/UnityAnalyticsAttachSDK.html>`_ the
  ``RealmController.cs`` script to the "RealmController" object by clicking the
  ``Game Object`` to open its `inspector window
  <https://docs.unity3d.com/Manual/UsingTheInspector.html>`_ and dragging and
  drop the ``/Assets/Scripts/RealmController.cs`` file into its inspector
  window.

  In later steps, you will add functionality to the ``RealmController`` script
  to perform the following:
  
  - Open a realm.
  - Set a logged-in ``Player``.
  - Interact with the ``Player`` and ``Stat`` models.
  - Create, read, update, and delete the current playthrough ``Stat`` object.
  
  .. note:: 

     The ``RealmController.cs`` script contains a ``Start()`` method that
     automatically attaches the ``AuthenticationManager.cs``, ``LeaderboardManager.cs``,
     and ``ScoreCardManager.cs`` scripts to their respective UI GameObjects. These
     scripts allow you to interact with the UI Game Objects you created through
     C# code.
  
---
title: Open a Realm
ref: open-realm
content: |
  Open the ``RealmController.cs`` file with a text editor, where we'll implement a
  function to open a {+realm+}. To open a {+realm+} instance that you will use
  throughout the ``RealmController`` class, add the following code to the
  ``GetRealm()`` method:

  .. code-block:: csharp

     return Realm.GetInstance();
---
title: Set a Logged In User
ref: set-logged-in-user
content: |
  In the ``RealmController.cs`` file, you will need to implement a function to set
  the logged-in user. The ``AuthenticationManager.cs`` file calls this function
  when a user clicks the "Login & Start" button.
  
  The ``RealmController.setLoggedInUser()`` method takes a string, userInput.
  You will create code to do the following in this method:
  
  - Query the {+realm+} to determine if a ``Player`` object already exists for the
    given userInput. 
  - Create an if-else block that creates a new ``Player`` and a new ``Stat`` {+realm+}
    object if the ``Player`` does not exist, and uses the existing ``Player`` and
    creates a new ``Stat`` object if the ``Player`` does exist.

  Add the following code to your ``RealmController.setLoggedInUser()`` method:

  .. code-block:: csharp

     // query the realm to find any Player objects with the matching name
     var matchedPlayers = realm.All<Player>().Where(p => p.Name == userInput);
     if (matchedPlayers.Count() > 0){
         currentPlayer = matchedPlayers.First(); // if a player exists set the RealmController's currentPlayer to the first match
         var s1 = new Stat(); // create a new Stat object for the current playthrough of the game
         s1.StatOwner = currentPlayer; // set the Stat object's owner as the currentPlayer

         // create a write transaction to store the data in {+realm+}
         realm.Write(() =>
         {
             currentStat = realm.Add(s1);
             currentPlayer.Stats.Add(currentStat);
         });
     }else{
        // if a player does not exist, create one
         var p1 = new Player();
         p1.Id = ObjectId.GenerateNewId().ToString();
         p1.Name = userInput;

         // create a new Stat object for the current playthrough of the game
         var s1 = new Stat();
         s1.StatOwner = p1; // set the Stat object's owner as the new player

         // create a write transaction to store the data in {+realm+}
         realm.Write(() =>
         {
             currentPlayer = realm.Add(p1);  // set the RealmController's currentPlayer to the newly created player {+realm+} object 
             currentStat = realm.Add(s1);
             currentPlayer.Stats.Add(currentStat);
         });
     }

  After the above code is executed, the ``RealmController.setLoggedInUser()``
  function calls ``startGame()`` to begin the timer. The timer increments the
  RealmController's runTime variable, and we use the runTime variable to
  calculate bonus points in the ``playerWon()`` method when the game has
  completed.
---
title: Update the Stats and Watch for Changes
ref: watch-for-changes-to-stat-object
content: |
  You've set the current Scorecard to the initial playthrough statistics for the
  current playthrough of the game, but collecting tokens or defeating
  enemies will not impact the current ``Stat`` object yet. To fix that, you'll edit the
  ``collectToken()`` an ``defeatEnemy()`` methods in the ``RealmController``.


  Add the following code to the ``RealmController.collectToken()`` method to
  perform a :doc:`write transaction
  </sdk/dotnet/fundamentals/write-transactions>` and update the variable
  ``currentStat`` that you created in the last step:

  .. code-block:: csharp

     realm.Write(() =>
      {
          currentStat.TokensCollected += 1;
      });

  Call the ``collectToken()`` method when the player collides with the token
  instance. This occurs in the platformer microgame file:
  ``/Assets/Scripts/Mechanics/TokenInstance.cs``.
  In the ``TokenInstance.cs`` file, the ``OnPlayerEnter()`` occurs when a player
  has collided with the token instance. Add the following code to
  ``OnPlayerEnter()`` after ``collided=true``.

  .. code-block:: csharp

     RealmController.collectToken();

  Add the following code to the ``RealmController.defeatEnemy()`` method to
  perform a :doc:`write transaction
  </sdk/dotnet/fundamentals/write-transactions>` and update the variable
  ``currentStat`` that you created in the last step:

  .. code-block:: csharp

     realm.Write(() =>
      {
          currentStat.EnemiesDefeated += 1;
      });

  Call the ``defeatEnemy()`` method in the ``/Assets/Scripts/Gameplay/EnemyDeath.cs``
  file in the top of the ``Execute()`` method.

   .. code-block:: csharp
 
      RealmController.defeatEnemy();
 
   Finally, create a listener that reacts to changes to the current
   playthrough's Stat and updates the Scorecard in the UI. In the
   ``ScoreCardManager.cs`` file, you can add a change listener to the current
   Stat {+realm+} object defined as the ``RealmController.currentStat``
   variable. In the ``watchForChangesToCurrentStats()`` method, handle the ``Stat`` object's
   :dotnet-sdk:`PropertyChanged event<Realms.RealmObjectBase.html#Realms_RealmObjectBase_PropertyChanged>`:
   
   .. code-block:: csharp
 
      propertyHandler = new PropertyChangedEventHandler((sender, e) => updateCurrentStats());
      currentStat.PropertyChanged += propertyHandler;

  The Scorecard now updates if the player defeats an enemy or collects a token.

  .. figure:: /images/unity-tutorial-defeatEnem-collectTok-functionality.gif
     :width: 350px
     :alt: Select Authentication.uxml as source asset
---
title: Restart the Game When the Player Wins
ref: restart-game-on-win
content: |
  When the player reaches the end of the Microgame level, the game is complete,
  but nothing else happens. To expand upon this, you will update the code to do
  the following when the player wins the game:

  - Calls the ``RealmController.playerWon()`` method to calculate and write the final score to {+realm+}
  - Displays a dialog with the final score
  - Respawns the player and restarts the game if the player clicks the restart button


  Navigate to the Platformer Microgame file, ``/Assets/Scripts/Gameplay/PlayerEnteredVictoryZone.cs``,
  in your text editor. This script is executed when the player enters the victory zone. 

  To create a dialogue, you'll need the `UnityEditor.EditorUtility
  <https://docs.unity3d.com/ScriptReference/EditorUtility.html>`_ class. Add the
  following code to the top of the file:

  .. code-block:: csharp
 
     using UnityEditor;

  Replace the existing ``Execute()`` method in the PlayerEnteredVictoryZone
  script with the snippet below:

  .. code-block:: csharp
 
     public override void Execute()
     {
         var finalScore = RealmController.playerWon();
         var didClickRestart = EditorUtility.DisplayDialog("You won!", $"Final Score = {finalScore}", "restart game");
         if (didClickRestart == true)
         {
            Simulation.Schedule<PlayerSpawn>(2);
            RealmController.restartGame();
         }
     }
---
title: Delete the Current Playthrough Stats When the Player Loses
ref: restart-game-on-win
content: |
  When the player loses by colliding with an enemy or by falling from a
  platform, the game starts a new playthrough and respawns the player back to
  the start point but does not create a new ``Stat`` object for the new playthrough.
  To expand upon this, you'll perform the following when the player loses the game:

  - Update the ``RealmController.deleteCurrentStat()`` method to delete the current ``Stat`` object for the current playthrough
  - Call the ``RealmController.deleteCurrentStat()`` method
  - Call the ``RealmController.restartGame()`` method to create a new ``Stat`` object for the new playthrough 

  Navigate to the ``RealmController.deleteCurrentStat()`` method and add the following code at the bottom of that method:

  .. code-block:: csharp
 
     realm.Write(() =>
      {
          realm.Remove(currentStat);
          currentPlayer.Stats.Remove(currentStat); // remove the reference to the currentStat from the currentPlayer object
      });
  
  Next, open the Platformer Microgame file,
  ``/Assets/Scripts/Gameplay/PlayerDeath.cs``, which handles the player death
  event. Add the following code to the end of the PlayerDeath's ``Execute()``
  method:

  .. code-block:: csharp
 
     RealmController.deleteCurrentStat();
     RealmController.restartGame();

  Return to the Unity Editor, and click play to enter ``play mode``. The next
  time your player loses,  the game respawns the player to the start point with a new
  ``Stat`` object showing 0 enemies defeated, 0 tokens collected.
---
title: Customize Your Game Assets (Optional)
ref: customize-game
content: |
  To add a personal touch to the game, you can modify its assets from the Unity
  Editor. Navigate to ``Assets/Tiles`` in the `Project Window
  <https://docs.unity3d.com/Manual/ProjectView.html>`_ to find a set of tiles
  that the game uses. 

  To modify a tile, click the tile to open its `inspector window
  <https://docs.unity3d.com/Manual/UsingTheInspector.html>`_. From the inspector
  window, you can change the sprite that the tile uses and its color.

  .. figure:: /images/unity-tutorial-customize-game-find-tiles.png
     :width: 500px
     :alt: Customize Tiles

  In the example below, we replaced the fence tile's sprite with the
  ``fence_brown`` sprite that comes with the Platformer Microgame.

  .. figure:: /images/unity-tutorial-customize-change-sprite.png
     :width: 350px
     :alt: Customize Fence Sprite
     
  You can choose any tile colors and sprites you would like. We went with the
  following for an earth-toned and friendly look:

  .. list-table::
    :header-rows: 1
 
    * - Tile Name
      - Sprite
    
    * - Fence
      - fence_brown

    * - House
      - house_green

    * - Plant
      - plant_green

    * - TileFloatingLeftEdge
      - TileFloatingLeftEdge_green
   
    * - TileFloatingRightEdge
      - TileFloatingRightEdge_green

    * - TileFloatingMiddle
      - TileFloatingMiddle_green

    * - TileGround
      - TileGroundDark_green

    * - TileGroundTop
      - TileGroundTop_green

  .. figure:: /images/unity-tutorial-customize-final-look.png
     :width: 500px
     :alt: Customize Unity Game - Final Look
---
title: Run and Test
ref: run-and-test
content: |
  Once you have completed the code, you can run the app and check its functionality.

  Click the play button on the top of the screen to enter `play mode
  <https://docs.unity3d.com/Manual/GameView.html>`_ and play the game. Once the
  Unity Editor opens the `GameView
  <https://docs.unity3d.com/Manual/GameView.html>`_, here are some things you
  can try out:

  - Logging in with a username.
  - Achieving a new high score and seeing the leaderboard update with it on the next playthrough.
  - Achieving a new high score using a different user and seeing the leaderboard update with the highscore on the next playthrough.