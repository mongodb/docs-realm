---
title: Download and Import Unity's Platformer Microgame
ref: download-and-import-unity-platform-microgame
content: |
  Unity Hub comes pre-installed with templates, such as the Platformer
  Microgame, to learn to develop games on the Unity editor. In later steps, you
  will import and Realm functionality to the game. 

  Click the Learn tab on the left side of Unity Hub to view the list of template projects.

  .. figure:: /images/unity-click-learn-tab.png
     :width: 750px
     :alt: Unity Click Learn Tab

  Scroll to the Platformer Microgame and click it. On the Modal that appears,
  click the "Download Project" button to download the project.  

  .. figure:: /images/unity-scroll-to-platformer-microgame.png
     :width: 750px
     :alt: Unity Scroll to Platformer Microgame

  .. figure:: /images/unity-download-platformer-microgame.png
     :width: 350px
     :alt: The cluster selection dropown menu

  Click "Open Project" to open the project in Unity.  

  .. figure:: /images/unity-open-platformer-microgame.png
     :width: 350px
     :alt: Unity Open Platformer Microgame
---
title: Load the Template's Scene
ref: load-template-scene
content: |
  When you open the Platformer Microgame template, Unity prompts you with the
  option to :guilabel:`Load Scene` or :guilabel:`Load Tutorials`. 
  
  .. figure:: /images/unity-load-tutorials-or-load-scene.png
     :width: 750px
     :alt: Load the Template Scene
  
  If you are new to developing with Unity, click :guilabel:`Load Tutorials` to
  learn Unity editor basics, interacting with `GameObjects
  <https://docs.unity3d.com/ScriptReference/GameObject.html>`_, and more. Once
  you feel comfortable working with the Unity Editor, you can continue to the
  next step. Alternatively, if you are already comfortable working with the
  Unity editor, click :guilabel:`Load Scene` and continue to the next
  step in this tutorial.

  Once the scene is loaded, click the play button on the top of the
  screen to enter `play mode <https://docs.unity3d.com/Manual/GameView.html>`_
  and play the game. 

  .. figure:: /images/unity-click-to-enter-play-mode.png
     :width: 350px
     :alt: Enter Play Mode

  To play the game, use the arrow keys to move your character, and the spacebar
  to jump. Hop on the "red slime" enemies to defeat them, making them disappear.
  Collide your character with the yellow "tokens" to collect them. Get to the
  end of the level to win the game. 

  .. figure:: /images/unity-view-game-in-play-mode.png
     :width: 500px
     :alt: View Game in Play Mode

  In later steps, you will use {+realm+} to record how many enemies the player
  defeated per playthrough, how many tokens were collected, and a score.
---
title: Update Your Project Manifest 
ref: update-project-manifest
content: |
  Unity uses the `Project Manifest
  <https://docs.unity3d.com/Manual/upm-manifestPrj.html>`_ to determine packages
  to install into your project. You'll need to update your Project Manifest to
  install {+realm+} and the Unity UI ToolKit and UI Builder packages to develop user interfaces to
  interact with and display data stored in {+realm+}. 
  
  .. note:: Install the Latest Versions of the Necessary Packages

     The code below lists the latest versions of the necessary packages at the
     time of writing this documentation. Check the links below to see if there
     is a later version to install and replace the versions below with the
     latest versions available:

     - `{+service-short+} .NET Releases <https://github.com/realm/realm-dotnet/releases>`_
     - `com.unity.ui Changelog <https://docs.unity3d.com/Packages/com.unity.ui@1.0/changelog/CHANGELOG.html>`_
     - `com.unity.ui.builder Changelog <https://docs.unity3d.com/Packages/com.unity.ui.builder@1.0/changelog/CHANGELOG.html>`_

  Add the following to your project's ``/Assets/Packages/manifest.json`` file,
  replacing the version below with the latest version:

  .. code-block:: json

     {
       "dependencies": {
         // ... 
         "io.realm.unity": "10.5.0",
         "com.unity.ui": "1.0.0-preview.16",
         "com.unity.ui.builder": "1.0.0-preview.17"
       },
       "scopedRegistries": [
         {
           "name": "NPM",
           "url": "https://registry.npmjs.org/",
           "scopes": [
             "io.realm.unity"
           ]
         }
       ]
     }

  .. note:: 

     UI ToolKit and UI Builder are `preview packages
     <https://docs.unity3d.com/Manual/pack-preview.html>`_ that are in
     development by the Unity engineering team. While they provide a simple API
     to develop user interfaces for a tutorial, they should not be used in
     production yet.
---
title: Clone the Realm Tutorial Repository
ref: clone-the-repository
content: |
  Now that {+realm+}, UI Builder, and UI Toolkit are installed into your
  project, you can begin recording data into {+realm+} and building a user
  interface that can read and interact with that data.

  We've already put together a respository that has most of the code you'll need
  to accomplish that. You can clone the Realm Tutorial repository directly from
  :github:`GitHub <mongodb-university/realm-tutorial-unity>`:

  .. code-block:: shell

     cd <your-unity-microplatformer-game-path>/Assets/Scripts
     git clone --branch start https://github.com/mongodb-university/realm-tutorial-unity.git

  .. tip::
   
     The ``start`` branch is an incomplete version of the Realm Tutorial repository that you will
     complete in this tutorial. To view a complete local-only (non-sync) version of the scripts:

     1. Navigate to the root directory of the client application repository:

        .. code-block:: shell

           cd realm-tutorial-unity

     #. Check out the ``local`` branch:

        .. code-block:: shell

           git checkout local
---
title: Explore the Realm Tutorial Repository
ref: explore-the-realm-tutorial-repository
content: |

  In your text editor of choice, such as `Visual Studio
  <https://docs.microsoft.com/en-us/visualstudio/>`_,  you can see the script
  files you will need to add to the game. The relevant files are as follows:

  .. cssclass:: config-table
  .. list-table::
     :header-rows: 1
     :widths: 40 60
     
     * - File
       - Purpose

     * - Stylesheet.uss
       - `USS <https://docs.unity3d.com/Manual/UIE-USS.html>`_ file with the
         global styles for your project.

     * - Leaderboard.uxml
       - `UXML <https://docs.unity3d.com/Manual/UIE-UXML.html>`_ file that is
         mostly empty but serves as a base for the leaderboard UI to be created later.
     
     * - LeaderboardManager.cs
       - Builds upon the base Leaderboard that was created in Leaderboard.uxml
         and expands it using {+realm+} to show the highest game scores.
     
     * - Scorecard.uxml
       - `UXML <https://docs.unity3d.com/Manual/UIE-UXML.html>`_ file that is
         mostly empty but serves as a base for the UI for the player's scores to
         be created later.

     * - ScoreCardManager.cs
       - Builds upon the base ScoreCard that was created in Scorecard.uxml and
         expands it using {+realm+} to show the player's statistics (stats) for their
         current playthrough.

     * - AuthenticationScreen.uxml
       - `UXML <https://docs.unity3d.com/Manual/UIE-UXML.html>`_ file with the
         entire UI for the Authentication Screen. This UI allows players to input
         their username and start the game.

     * - AuthenticationManager.cs
       - Interacts with the TextField's of AuthenticationScreen.uxml to implement user login.

     * - RealmController.cs
       - A script containing most of the {+realm+} code logic, such as opening a
         {+realm+}, recording the player stats for the current playthrough, deleting
         the current playthrough, calculating final scores, restarting the game,
         and closing the {+realm+}.

     * - PlayerModel.cs
       - Script containing a Player :ref:`{+frontend-schema+} <dotnet-object-models-and-schemas>`.

     * - StatModel.cs
       - Script containing a Statistics :ref:`{+frontend-schema+} <dotnet-object-models-and-schemas>`.

     * - Constants.cs (Part 2)
       - Part 2: Declare the Realm App ID for the {+sync+} portion of the tutorial.

---
title: Explore the Schemas
ref: explore-schemas
content: |
  In the ``realm-tutorial-unity`` project that you have cloned, navigate to the
  ``PlayerModel.cs`` and ``StatModel.cs`` files in a text editor. These C#
  classes define the schemas for the objects we store in our realms. 
  
  Note the following about the schemas:

  - A ``Stat`` is a {+realm+} object representing the statistics of a playthrough of the
    game. For instance, in one playthrough a player may have defeated 7 enemies,
    collected 20 tokens, and had a score of 200. Each Stat belongs to a player.

  - A ``Player`` is a {+realm+} object representing the user's logged in
    character. Each player has a collection (IList) of ``Stats`` of which they
    own. 

  - A ``Player`` has a string property, ``_id``, that defines the Players's unique partition.

  - A ``Stat`` has a ``statOwner`` property that indicates the Player that the Stat belongs to.
---
title: Create UI Game Objects
ref: create-ui-game-objects
content: |
  Navigate to your Unity Editor's `hierarchy window
  <https://docs.unity3d.com/Manual/Hierarchy.html>`_ to create UI game objects
  that will display the authentication screen, game leaderboard, and player's
  score card for the current playthrough of the game. 

  Right click and select UI > Canvas to create a `Canvas
  <https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/UICanvas.html>`_
  GameObject that will contain your UI elements. 

  .. figure:: /images/unity-create-canvas.png
     :width: 350px
     :alt: Create the Canvas Game Object

  Next, as a child of the Canvas game object, create three `UIDocuments
  <https://docs.unity3d.com/2021.2/Documentation/ScriptReference/UIElements.UIDocument.html>`_
  by right clicking the Canvas object and selecting UI Toolkit > UI Document
  three times. Name these game objects: AuthenticationScreen, Leaderboard, and
  Scorecard respectively.

  .. figure:: /images/unity-create-ui-documents.png
     :width: 350px
     :alt: Create the UI Documents

  Your UI hierarchy should look something like this:

  .. figure:: /images/unity-final-ui-hierarchy.png
     :width: 350px
     :alt: Final UI Hierarchy

  Next attach the UXML files to the UI GameObjects. Click the
  "AuthenticationScreen" GameObject to open the `inspector window
  <https://docs.unity3d.com/Manual/UsingTheInspector.html>`_. Then select
  "Authentication" in the "Source Asset" field to set the AuthenticationScreen's
  UXML file to Authentication.uxml.

  .. figure:: /images/unity-select-authentication-uxml-source-asset.png
     :width: 350px
     :alt: Select Authentication.uxml as source asset

  Repeat this step twice, setting the Leaderboard GameObject's Source Asset to
  "Leaderboard" and the ScoreCard GameObject's Source Asset to "ScoreCard".

  Finally, click the play button to enter play mode. You should see something like the following:

  .. figure:: /images/unity-tutorial-static-ui.png
     :width: 500px
     :alt: Unity Tutorial Game with Static UI

  Notice, that the "Login & Start" button does not work yet, and the
  username at the top right corner is a default value. 

---
title: Attach the C# Scripts to the UI Game Objects
ref: attach-scripts-to-ui-game-objects
content: |
  Now that you have created your UI Documents and set their UXML Source Assets,
  it's time to replace the default static values with dynamic values for the top
  leaderboard scores, player's username, and player's statistics for the current
  playthrough. To do this, you will attach the following scripts that you've
  cloned in step 5: 

  -  Attach the LeaderboardManager.cs to the Leaderboard GameObject.
  -  Attach the ScoreCardManager.cs to the ScoreCard GameObject.
  -  Attach the AuthenticationManager.cs to the AuthenticationScreen GameObject.

  To attach a C# script to a GameObject, click the GameObject to open the
  object's `inspector window
  <https://docs.unity3d.com/Manual/UsingTheInspector.html>`_. Click the "Add
  Component" button to add the "Scripts" field. Finally, select the desired C#
  file to attach the script.

  .. figure:: /images/unity-tutorial-attach-ui-script-gif.gif
     :width: 350px
     :alt: Attach UI Script to UI Game Object

  Repeat this step for each C# script specified above.
---
title: Create a RealmController Game Object
ref: create-realm-controller-object
content: |
  To get and set dynamic values for the Leaderboard, ScoreCard, and
  AuthenticationScreen components you need a GameObject to interact with
  {+realm+}. Create an empty GameObject and attach the RealmController script to
  it. To do this, right click the hierarchy window and select "Create Empty" and
  name the object "RealmController". Next, attach the "RealmController.cs"
  script to the "RealmController" object. 
  
  
  In later steps, you will add functionality to the RealmController script
  to perform the following:
  
  - open a realm
  - set a logged in player
  - interact with the player and stat models
  - create, read, update, and delete player stats
---
title: Open a Realm
ref: open-realm
content: |
  Open the RealmController.cs file with a text editor, where we'll implement a
  function to open a {+realm+}. To open a realm instance that you will use
  throughout the RealmController class, add the following code to the
  ``GetRealm()`` method:

  .. code-block:: csharp

     return Realm.GetInstance();
---
title: Set a Logged In User
ref: set-logged-in-user
content: |
  In the RealmController.cs file you will need to implement a function to set
  the logged in user. This function is called on a click event that has been
  created for you in the AuthenticationManager.cs file.
  
  The RealmController's ``setLoggedInUser()`` method takes a string, userInput. In this method,
  you will create code to do the following:
  
  - query the realm to determine if a player object already exists for the
    given userInput. 
  - create a conditional if else block that creates a player and a stat
    {+realm+} object if the player does not exist, and only create a stat
    {+realm+} object if the player does exist.

  Add the following code to your RealmController's ``setLoggedInUser()`` method:

  .. code-block:: csharp

     // query the realm to find any player objects with the matching name
     var matchedPlayers = realm.All<Player>().Where(p => p.Name == userInput);
     if (matchedPlayers.Count() > 0){
         currentPlayer = matchedPlayers.First(); // if a player exists set the RealmController's currentPlayer to the first match
         var s1 = new Stat(); // create a new Stat object for the current playthrough of the game
         s1.StatOwner = currentPlayer; // set the Stat object's owner as the currentPlayer

         // create a write transaction to store the data in {+realm+}
         realm.Write(() =>
         {
             currentStat = realm.Add(s1);
             currentPlayer.Stats.Add(currentStat);
         });
     }else{
        // if a player does not exist, create one
         var p1 = new Player();
         p1.Id = ObjectId.GenerateNewId().ToString();
         p1.Name = userInput;

         // create a new Stat object for the current playthrough of the game
         var s1 = new Stat();
         s1.StatOwner = p1; // set the Stat object's owner as the new player

         // create a write transaction to store the data in {+realm+}
         realm.Write(() =>
         {
             currentPlayer = realm.Add(p1);  // set the RealmController's currentPlayer to the newly created player {+realm+} object 
             currentStat = realm.Add(s1);
             currentPlayer.Stats.Add(currentStat);
         });
     }

  After the above code is executed, a function called ``startGame()`` is run to
  begin the timer. The timer increments the RealmController's runTime variable,
  and we use the runTime variable to calculate bonus points in the
  ``playerWon()`` method when the game has completed.
---
title: Update the Stats and Watch for Changes
ref: watch-for-changes-to-stat-object
content: |
  You've set the current score card to the player's initial stats for the
  current playthrough of the game, but currently collecting tokens or defeating
  enemies will not impact the player's stats. To fix that, you'll edit the
  ``collectToken()`` an ``defeatEnemy()`` methods in the realm controller.

  When a player collects a token, the ``collectToken()`` should be called and
  the variable ``currentStat``, that you created in the last step, should be
  updated in a write transaction. 

  .. code-block:: csharp

     realm.Write(() =>
      {
          currentStat.TokensCollected += 1;
      });

  Call the ``collectToken()`` method when the player collides with the token
  instance. This occurs in the platformer microgame file:
  ``/Assets/Scripts/Mechanics/TokenInstance.cs``.
  In the ``TokenInstance.cs`` file, the ``OnPlayerEnter()`` occurs when a player
  has collided with the token instance. Add the following code to
  ``OnPlayerEnter()`` after ``collided=true``.

  .. code-block:: csharp

     RealmController.collectToken();

  When a player hops on an enemy to defeat it, the RealmController's
  ``defeatEnemy()`` method should be called and the
  ``currentStat.EnemiesDefeated`` field should incremented in a write transaction.

  .. code-block:: csharp

     realm.Write(() =>
      {
          currentStat.EnemiesDefeated += 1;
      });

  Call the ``defeatEnemy()`` method in the
  ``/Assets/Scripts/Gameplay/EnemyDeath.cs``
  file in the top of the ``Execute()`` method

   .. code-block:: csharp
 
      RealmController.defeatEnemy();
 
   Finally, create a listener that reacts to changes to the current playthrough's
   Stat and updates the Scorecard in the UI. In the ``ScoreCardManager.cs`` file, you can
   add a change listener to the current Stat {+realm+} object that is stored in
   the ``RealmController.currentStat`` variable. In the
   ``watchForChangesToCurrentStats()`` method, handle the currentStat's
   :dotnet-sdk:`PropertyChanged event<Realms.RealmObjectBase.html#Realms_RealmObjectBase_PropertyChanged>`:
   
   .. code-block:: csharp
 
      var propertyHandler = new PropertyChangedEventHandler((sender, e) => updateCurrentStats());
      currentStat.PropertyChanged += propertyHandler;

   When you click play to enter play mode, the "Enemies Defeated" and "Tokens
   Collected" labels of the ScoreCard will update when the player defeats
   enemies or collects tokens.

  .. figure:: /images/unity-tutorial-defeatEnem-collectTok-functionality.gif
     :width: 350px
     :alt: Select Authentication.uxml as source asset
---
title: Restart the Game When the Player Wins
ref: restart-game-on-win
content: |
  Currently, when the player reaches the end of the Microgame level, the game is
  complete but nothing happens. To expand upon this, you'll create code to alert the final score when the game is
  won and restart the game.

  Navigate to the Platformer Microgame file
  ``/Assets/Scripts/Gameplay/PlayerEnteredVictoryZone.cs``
  in your text editor. This script is executed when the player enters the
  victory zone. 

  Replace the existing ``Execute()`` method in the PlayerEnteredVictoryZone script with one that does the following:

  - calls the RealmController's ``playerWon()`` method to calculate and write the final score to {+realm+}
  - displays a dialog with the final score
  - respawns the player and restarts the game if the player clicks the restart button

  .. code-block:: csharp
 
     public override void Execute()
     {
         var finalScore = RealmController.playerWon();
         var didClickRestart = EditorUtility.DisplayDialog("You won!", $"Final Score = {finalScore}", "restart game", "cancel");
         if (didClickRestart == true)
         {
            Simulation.Schedule<PlayerSpawn>(2);
            RealmController.restartGame();
         }
     }
---
title: Delete the Current Playthrough Stats When the Player Loses
ref: restart-game-on-win
content: |
  Currently, when the player loses by colliding with an enemy or by falling from a
  platform, the game starts a new playthrough and respawns the player back to
  the start point but does not create a new Stat object for the new playthrough.
  To expand upon this, you'll perform the following when the player loses the game:

  - Fill out the RealmController's ``deleteCurrentStat()`` method to delete the current Stat for the current playthrough
  - Call the RealmController's ``deleteCurrentStat()`` method
  - Call the RealmController's ``restartGame()`` method to create a new Stat object for the new playthrough 

  Navigate to the RealmController's ``deleteCurrentStat()`` method and add the following code at the bottom of that method:

  .. code-block:: csharp
 
     realm.Write(() =>
      {
          realm.Remove(currentStat);
          currentPlayer.Stats.Remove(currentStat); // remove the reference to the currentStat from the currentPlayer object
      });
  
  Next, open the ``/Assets/Scripts/Gameplay/PlayerDeath.cs`` which handles the
  player death event. Add the following code to the end of the PlayerDeath's ``Execute()``
  method:

  .. code-block:: csharp
 
     RealmController.deleteCurrentStat();
     RealmController.restartGame();

  Return to the Unity Editor, and click play to enter ``play mode``. The next
  time your player loses, you should be respawned to the start point with a new
  Stat object showing 0 enemies defeated, 0 tokens collected.
---
title: Customize Your Game Assets (Optional)
ref: customize-game
content: |
  To add your own flair to the game, you can modify it's assets. From the Unity
  Editor. Navigate to ``Assets/Tiles`` in the `Project Window
  <https://docs.unity3d.com/Manual/ProjectView.html>`_ to find a set of tiles
  that the game uses. 

  To modify a tile, click the tile to open its `inspector window
  <https://docs.unity3d.com/Manual/UsingTheInspector.html>`_. From the inspector
  window you can modify the sprite that the tile uses, and the color of that sprite.

  .. figure:: /images/unity-tutorial-customize-game-find-tiles.png
     :width: 350px
     :alt: Customize Tiles

  In the example below, the fence tile's sprite is replaced with the
  ``fence_brown`` sprite that comes with the Platformer Microgame.

  .. figure:: /images/unity-tutorial-customize-change-sprite.png
     :width: 350px
     :alt: Customize Fence Sprite
     
  You can choose any tile colors and sprites you would like. We went with the
  following for an earth-toned and friendly look:

  .. list-table::
    :header-rows: 1
 
    * - Tile Name
      - Sprite
    
    * - Fence
      - fence_brown

    * - House
      - house_green

    * - Plant
      - plant_green

    * - TileFloatingLeftEdge
      - TileFloatingLeftEdge_green
   
    * - TileFloatingRightEdge
      - TileFloatingRightEdge_green

    * - TileFloatingMiddle
      - TileFloatingMiddle_green

    * - TileGround
      - TileGroundDark_green

    * - TileGroundTop
      - TileGroundTop_green

  .. figure:: /images/unity-tutorial-customize-final-look.png
     :width: 350px
     :alt: Customize Unity Game - Final Look
---
title: Run and Test
ref: run-and-test
content: |
  Once you have completed the code, you can run the app and check its functionality.

  Click the play button on the top of the screen to enter `play mode
  <https://docs.unity3d.com/Manual/GameView.html>`_ and play the game. Once the
  Unity Editor opens the `GameView
  <https://docs.unity3d.com/Manual/GameView.html>`_, here are some things you
  can try out:

  - Logging in with a username.
  - Getting a new highscore and seeing the leaderboard update with it on the next playthrough.
  - Getting a new highscore using a different user, and seeing the leaderboard update with the highscore on the next playthrough.