.. _optimize-sync-atlas-usage:

=========================
Optimize Sync Atlas Usage
=========================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------

{+sync+} uses space in your app's synced Atlas cluster to store utility
data for sync. {+service+} minimizes that space usage via backend
compaction. You can optimize further by specifying a client maximum
offline time.

History
-------

The {+service-short+} backend keeps a history of :ref:`changes to
underlying data <changesets>`, similar to the :manual:`MongoDB oplog
</core/replica-set-oplog/>`. {+service-short+} uses this history to
synchronize data between backend and clients. {+service-short+} stores
this history in your synced Atlas cluster to enable {+sync+}.

.. _backend-compaction:

Backend Compaction
------------------

**Backend compaction** is a maintenance process that automatically
runs for all {+app+}s. During backend compaction, {+service-short+}
runs through history of changes used for synchronization. Compaction
removes changes that other changes later overwrite. Consider the
following example history:

.. code-block::

   CREATE table1.object1
   UPDATE table1.object1.x = 4
   UPDATE table1.object1.x = 10
   UPDATE table1.object1.x = 42

The following history would also converge to the same state:

.. code-block::

   CREATE table1.object1
   UPDATE table1.object1.x = 42

Compaction removes unnecessary steps from history to reduce its space
usage in your Atlas cluster. Additionally, compaction reduces the time
and data usage of client devices sync. Clients must download
fewer historical steps to converge on the same result.

Compacting some historical operations depends on awareness of client
sync states. Consider the following:

.. code-block::

   CREATE table2.object2
   CREATE table1.object1
   DELETE table2.object2

The following history would also converge on the same state:

.. code-block::

   CREATE table1.obj1

Because the history creates and then deletes ``object2``, clients don't
need to know that ``object2`` ever existed. However, if any client
synchronized the CREATE operation before the DELETE operation occurred,
they'll still need the DELETE operation to converge at the same point in
history. So instead, the compacted history includes a "trailing delete":

.. code-block::

   CREATE table1.object1
   DELETE table2.object2

Compaction removes any instruction that is later
overwritten by a future instruction. {+service-short+} is aware of
client sync states, and can also use that awareness to optimize
compaction. For instance, when a DELETE operation has been seen by all
clients, compaction can even remove the "trailing deletes" seen in the last
example.

Compaction runs regularly on all synced clusters as part of {+sync+}.

.. _client-maximum-offline-time:

Client Maximum Offline Time
---------------------------

The **client maximum offline time** controls when compaction can prune
extra history metadata, such as "trailing deletes," from history.
This indirectly changes how long a client can remain offline between
synchronization sessions with the backend. Clients that do not
synchronize for more than the specified number of days
may experience a :ref:`client reset <client-resets>` the next time they
connect with the backend.

The lower the client maximum offline time, the sooner compaction can
prune the extra metadata on old history. Less metadata means less storage
usage in your synced Atlas cluster.

Key Concepts
~~~~~~~~~~~~

In order for synchronization to converge at the same end state
as the backend and all other clients, a synchronization client requires
the full history of changes beginning immediately after the client's last
synchronization session. When a client does not check in for a long
period of time, compaction's metadata pruning can alter the history in
ways that prevent the client from converging on a common result. Since
synchronization relies on all clients converging on a common result,
the client cannot synchronize.

Consider the following example where history is aggressively pruned
of trailing deletes. The original history contained a CREATE and a
DELETE for ``table2.object2``:

.. code-block::

   CREATE table2.object2
   CREATE table1.object1
   DELETE table2.object2

Compaction pruned metadata older than the client maximum offline time
to produce the following history on the backend:

.. code-block::

   CREATE table1.obj1

However, a client contains this subset of history:

.. code-block::

   CREATE table2.object2
   CREATE table1.object1

Since compaction pruned the DELETE operation for ``table2.object2``, the
client never deletes that object. There is no way for the client to use
the pruned history to converge at the same state as the backend and all
other clients.

As a result, the client must complete a client reset before it can
resume synchronization. In a client reset scenario, the client deletes
the client-local copy of a {+realm+} and downloads the current state of
that {+realm+} from the backend. Synchronization then resumes using the
new copy of the {+realm+}.

The client maximum offline time of your {+app+} controls how long
compaction preserves the full history of data changes in a {+realm+}.
As a result, any clients who have not synchronized data in
*more than client maximum offline time days* must perform a client reset
the next time they connect with the backend.

Applications that do not specify the client maximum offline time always
preserve the full history, no matter how old. This means that clients can
connect after any period of time offline -- weeks, months, or even years
-- and synchronize changes from the backend. After a long period of time,
there may be a large number of changes for {+realm+}s with frequent
edits, so synchronization could take a large amount of time and data.

Set the Client Maximum Offline Time
-----------------------------------

.. tabs-realm-admin-interfaces::
   
   .. tab::
      :tabid: ui
      
      1. Select the :guilabel:`Sync` menu in the sidebar.

      2. Click the :guilabel:`Client Maximum Offline Time (Optional)` dropdown
         in the "Configuration" tab.

         .. figure:: /images/client-maximum-offline-time.png
           :width: 750px
           :alt: The client maximum offline time configuration in a disabled state.

      3. Click the :guilabel:`Enable Max Offline Time` toggle.

      4. Enter a number greater than or equal to 1 specifying a number of
         days for your application's client maximum offline time. The default
         value is 30 days.
   
   .. tab::
      :tabid: cli
      
      1. Pull a local copy of the latest version of your app with the
         following:

         .. code-block:: bash

            realm-cli pull --remote="<Your App ID>"

      2. You can configure the number of days for your application's
         client maximum offline time with the ``client_max_offline_days``
         property in your app's ``sync/config.json`` file:

         .. code-block:: json
            :caption: sync/config.json
           
            {
               "client_max_offline_days": 42,
            }

      3. Deploy the updated app configuration with the following:

         .. code-block:: bash

            realm-cli push --remote="<Your App ID>"
