.. _optimize-sync-atlas-usage:

=========================
Optimize Sync Atlas Usage
=========================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------

{+sync+} uses space in your app's synced Atlas cluster to store utility
data for sync. {+service+} minimizes that space usage via backend
compaction. You can optimize further by specifying a client maximum
offline time.

History
-------

The {+service-short+} backend keeps a history of :ref:`changes to
underlying data <changesets>`, similar to the :manual:`MongoDB oplog
</core/replica-set-oplog/>`. {+service-short+} uses this history to
synchronize data between backend and clients. {+service-short+} stores
this history in your synced Atlas cluster to enable {+sync+}.

.. _backend-compaction:

Backend Compaction
------------------

**Backend compaction** is a maintenance process that automatically
runs for all {+app+}s. During backend compaction, {+service-short+}
runs through history of changes used for synchronization. Compaction
removes changes that other changes later overwrite. Consider the
following example history:

.. code-block::

   CREATE table1.object1
   UPDATE table1.object1.x = 4
   UPDATE table1.object1.x = 10
   UPDATE table1.object1.x = 42

The following history would also converge to the same state:

.. code-block::

   CREATE table1.object1
   UPDATE table1.object1.x = 42

Compaction removes unnecessary steps from history to reduce its space
usage in your Atlas cluster. Additionally, compaction reduces the time
and data usage of sync. Clients must download fewer historical steps to
converge on the same result.

Compaction removes any instruction that is later
overwritten by a future instruction. Compaction runs regularly on all
synced clusters as part of {+sync+}.

.. _advanced-backend-compaction:

Advanced Backend Compaction
~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Advanced backend compaction** uses client sync states to optimize
history beyond the level of normal compaction. Consider the following
{+realm+} history:

.. code-block::

   CREATE table2.object2
   CREATE table1.object1
   DELETE table2.object2

Because there is a gap in time between the CREATE and DELETE operations
for ``table2.object2``, any client could have synchronized the CREATE
operation, but not the DELETE operation. As a result, compaction can
remove the CREATE operation, but not the DELETE operation:

.. code-block::

   CREATE table1.object1
   DELETE table2.object2

This guarantees client convergence. If the history didn't include the
DELETE operation, clients that synced the CREATE operation would never
delete ``table2.object2``, but other clients would never create that
object in the first place. Instead, all clients get a command to
delete that object, and any clients who never created ``table2.object2``
in the first place ignore the DELETE.

The following history uses advanced backend compaction to converge on
the same state:

.. code-block::

   CREATE table1.obj1

Because the history creates and then deletes ``object2``, clients don't
need to know that ``object2`` ever existed. However, this optimization
can prevent convergence for clients who saw some, but not all, of this
section of history. As a result, advanced backend compaction only
occurs for history older than the client maximum offline time.

Advanced backend compaction only runs on clusters with a
client maximum offline time.

.. _client-maximum-offline-time:

Client Maximum Offline Time
---------------------------

The **client maximum offline time** controls when compaction can apply
:ref:`advanced-backend-compaction <advanced-backend-compaction>`.
This indirectly changes how long a client can remain offline between
synchronization sessions with the backend. Clients that do not
synchronize for more than the specified number of days
may experience a :ref:`client reset <client-resets>` the next time they
connect with the backend.

The lower the client maximum offline time, the sooner compaction can
apply advanced optimizations to older history. Less metadata means less
storage usage in your synced Atlas cluster.

Key Concepts
~~~~~~~~~~~~

In order for synchronization to converge at the same end state
as the backend and all other clients, a synchronization client requires
the full history of changes beginning immediately after the client's last
synchronization session. When a client does not check in for a long
period of time, advanced backend compaction can alter the history in
ways that prevent the client from converging on a common result. Since
synchronization relies on all clients converging on a common result,
the client cannot synchronize.

Consider the following example where history is aggressively pruned
of trailing deletes. The original history contained a CREATE and a
DELETE for ``table2.object2``:

.. code-block::

   CREATE table2.object2
   CREATE table1.object1
   DELETE table2.object2

Advanced backend compaction produced the following history on the backend:

.. code-block::

   CREATE table1.obj1

However, a client contains this subset of history:

.. code-block::

   CREATE table2.object2
   CREATE table1.object1

Since compaction pruned the DELETE operation for ``table2.object2``, the
client never deleted that object. The client cannot converge to the same
state as the backend and all other clients.

As a result, the client must complete a client reset before it can
resume synchronization. In a client reset scenario, the client deletes
the client-local copy of a {+realm+} and downloads the current state of
that {+realm+} from the backend. Synchronization then resumes using the
new copy of the {+realm+}.

The client maximum offline time controls how long your backend waits
before applying advanced backend compaction. After the specified number
of days without syncing, clients experience a client reset the next time
they connect with the backend.

Applications that do not specify the client maximum offline time never
apply advanced backend compaction to any history. This means that clients
can connect after any period of time offline -- weeks, months, or even years
-- and synchronize changes from the backend. After a long period of time,
there may be a large number of changes for {+realm+}s with frequent
edits, so synchronization could take a large amount of time and data.

Set the Client Maximum Offline Time
-----------------------------------

.. tabs-realm-admin-interfaces::
   
   .. tab::
      :tabid: ui
      
      1. Select the :guilabel:`Sync` menu in the sidebar.

      2. Click the :guilabel:`Client Maximum Offline Time (Optional)` dropdown
         in the "Configuration" tab.

         .. figure:: /images/client-maximum-offline-time.png
           :width: 750px
           :alt: The client maximum offline time configuration in a disabled state.

      3. Click the :guilabel:`Enable Max Offline Time` toggle.

      4. Enter a number greater than or equal to 1 specifying a number of
         days for your application's client maximum offline time. The default
         value is 30 days.
   
   .. tab::
      :tabid: cli
      
      1. Pull a local copy of the latest version of your app with the
         following:

         .. code-block:: bash

            realm-cli pull --remote="<Your App ID>"

      2. You can configure the number of days for your application's
         client maximum offline time with the ``client_max_offline_days``
         property in your app's ``sync/config.json`` file:

         .. code-block:: json
            :caption: sync/config.json
           
            {
               "client_max_offline_days": 42,
            }

      3. Deploy the updated app configuration with the following:

         .. code-block:: bash

            realm-cli push --remote="<Your App ID>"
