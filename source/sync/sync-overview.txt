.. _sync-overview:

===================================
Sync Data Between Atlas and Clients
===================================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------

Realm sync enables you to share data between
:term:`Realm clients <Realm client>` and a
:term:`synced Atlas cluster <synced cluster>`.
Realm sync handles data serialization,
network recovery, and conflict resolution automatically.

.. _the-connectivity-problem:

The Connectivity Problem
------------------------

:term:`Realm Database` is a local, mobile database in
which your app can store data. Eventually, most apps
need to share that data with the outside world.
Consider a few examples:

- A team app collaborates in real-time on a shared
  document across the Internet.

- A front-line worker app fills out a report while
  working somewhere with low or no network connectivity.

- An IoT device uploads its sensor data to the cloud.

Traditionally, developers:

1) Set up a server hosting a database.

2) Set up a service hosting a REST API that authenticates users,
   deserializes requests, translates the data into an object model
   for the database, and then serializes from one of those objects
   into a database query.

3) Communicate with that REST API via HTTP over the internet from the
   client API, serializing data into REST endpoint API calls.

For many use cases, this works well. However, not every
developer needs to re-implement:

- an authentication system

- a database data access layer

- a collection of REST endpoints to create, read, update, and destroy
  every object in the application's object model

Additionally, developers need to solve the following problems for every
client platform:

- serialization

- a consistent schema of objects

- gracefully handling network failures and slowdowns

- resolving conflicts between changes to the same data on different
  clients

MongoDB Realm helps you avoid re-implementing complex, common tasks
like authentication, database access, object serialization, and
authorization, and makes it easy to manage a consistent schema of
objects for your database and each client platform.

Realm sync handles network access and conflict resolution in a
background thread of your application, so your application logic
stays the same regardless of network conditions.

.. _offline-first:

Think Offline-first
-------------------

Realm sync is built on the assumption that connectivity will
drop. We call this mentality **offline-first**. After you
make changes to the local Realm on the client device, the Realm
SDK automatically sends the changes to the server as soon
as possible. Likewise, the Realm SDK automatically receives
changes from the server and integrates those changes into
the local Realm. In effect, you continue to work with the
local Realm without moment-to-moment concern for network
connectivity or lack thereof.

The offline-first design leads to some of the main benefits
of MongoDB Realm:

Seamless User Experience:
  Users interact with local data with zero latency
  regardless of their moment-to-moment connectivity.

Live Objects Across Devices:
  MongoDB Realm's :ref:`live object <live-object>` concept
  extends across devices: updates on one device sync to
  the corresponding objects on other devices.
  :doc:`Notifications </crud/notifications>` based on these
  updates make it easy to update the application UI to
  react to local and remote changes.

It's Automatic:
  Sync is built into the Realm SDK. You do not need to write
  your own synchronization protocol and deal with connectivity
  issues when synchronizing data. The Realm Sync protocol is
  the same across platforms. Realm handles passing the
  objects across the network automatically, so there is no
  need to map from one platform's database to another or
  serialize and deserialize objects in order to send and
  receive them over the network.

Despite these advantages, offline-first design introduces one
problem: if client devices can remain offline while changes
are made locally and remotely, when those client devices
come back online, those changes must be shared between devices.
To make matters more complicated, every client device must
arrive at the same state when all changes have been synced.
This is why Realm sync includes **automatic conflict resolution**.

.. _conflict-resolution:

Resolving Conflicts
-------------------

Realm sync's conflict resolution engine is deterministic.
Changes received out-of-order eventually converge on the
same state across the server and all clients. As such, Realm
sync is :wikipedia:`strongly eventually consistent
<Eventual_consistency#Strong_eventual_consistency>`.

.. admonition:: Realm Sync's Internal Conflict
   :class: note

   From MongoDB Realm's perspective, changesets may
   arrive any time that connectivity allows. There is no
   guarantee that an earlier-timestamped changeset from one
   client actually arrives before a later-timestamped
   changeset from another client. As a result, the server
   has to be able to process events out-of-order. MongoDB Realm
   keeps a per-Realm transaction history to deal with the
   out-of-order nature of messages.

In simple terms, Realm sync's conflict resolution comes down
to **last write wins**. Realm sync also uses more
sophisticated techniques like :wikipedia:`operational
transform <Operational_transformation>` to handle, for
example, insertions into lists.

.. _scalability:

Use Case Profiles and Scalability
---------------------------------

In practice, reliable conflict resolution is complex and
CPU-intensive. Too many writers writing on the same realm
concurrently can impact performance, leading to scalability
concerns.

To use Realm sync effectively, it is important to understand
the different use case profiles and their scalability
implications. You can categorize Realm sync use cases in
terms of **number of writers, number of readers**:

Multiple writer, multiple reader:
  The real-time collaboration app use case.
  Generally speaking, MongoDB Realm can handle up to 30
  concurrent writers per Realm. As such, each 'project' on
  which users can collaborate works best in its own Realm.

Single writer, multiple reader:
  When a single writer, such as a publisher
  application on the backend, inserts data into a global
  Realm that all frontend clients can read from but not
  write to. This can scale past tens of thousands of
  concurrent users.

Single writer, single reader:
  When each user has their own private Realm to
  store, e.g., user account information, preferences, or the
  individual user's shopping cart. As long as only the user
  or a backend application interacts with the realm data,
  the performance is ideal and scales linearly with number
  of users.

To get the best performance from Realm sync, design your
Realm app with use case profiles in mind. If you
intend to have many concurrent writers, split projects
across Realms.

Summary
-------

- Realm sync enables offline-first app development by handling network
  loss and recovery automatically.
- Realm sync has a built-in conflict resolution engine that guarantees
  strong eventual consistency.
- To get the best performance with Realm sync, it is essential to
  understand the different use case profiles and their implications
  on scalability.
